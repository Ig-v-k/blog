<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Who is that properly designed object in an object-oriented world? What name, behavior, habits, interfaces, and friends does he have? Let&apos;s look at it from a different perspective." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Seven Virtues of a Good Object"/> <meta name="twitter:description" property="og:description" content="Who is that properly designed object in an object-oriented world? What name, behavior, habits, interfaces, and friends does he have? Let&apos;s look at it from a different perspective."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2014/11/20/seven-virtues-of-good-object.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d7375766803"/> <link rel="apple-touch-icon" href="/favicon.ico?d7375766803"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d7375766803"/> <link rel="stylesheet" href="/css/icons.css?d7375766803"/> <link rel="canonical" href="https://www.yegor256.com/ru/2014/11/20/seven-virtues-of-good-object.html" /> <title>Seven Virtues of a Good Object</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Seven Virtues of a Good Object</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Martin Fowler <a href="http://martinfowler.com/bliki/InversionOfControl.html">says</a>:</p><p>Функции, организованные в классы? Со всем уважением, это неправильно. И это очень распространенное заблуждение о классе в объектно-ориентированном программировании. Классы не являются организаторами функций. И объекты не являются структурами данных.</p><p>Итак, что такое “правильный” объект? Какой из них не является правильным? Чем они отличаются? Несмотря на то, что это очень полемическая тема, она очень важна. Если мы не понимаем, что такое объект, как мы можем писать объектно-ориентированное программное обеспечение? Ну, благодаря Java, Ruby и другим, мы можем. Но насколько это будет хорошо? К сожалению, это не точная наука, и есть много мнений. Вот мой список качеств хорошего объекта.</p><p>Прежде чем мы начнем говорить об объектах, давайте определим, что такое <em>класс</em>. Это место, где рождаются объекты (также известные как <em>инстанцированные</em>). Основная ответственность класса заключается в <em>создании</em> новых объектов по требованию и <em>уничтожении</em> их, когда они больше не используются. Класс знает, как его дочерние элементы должны выглядеть и как они должны себя вести. Другими словами, он знает, каким <em>контрактам</em> они должны следовать.</p><p>Иногда я слышу, что классы называют “шаблонами объектов” (например, <a href="https://en.wikipedia.org/wiki/Class_%28computer_programming%29">Википедия так говорит</a>). Это определение не является верным, потому что оно ставит классы в пассивное положение. Это определение предполагает, что кто-то получит шаблон и построит объект, используя его. Технически говоря, это может быть верно, но концептуально это неправильно. Никто другой не должен быть вовлечен - есть только класс и его дочерние элементы. Объект просит класс создать другой объект, и класс его создает; вот и все. Ruby намного лучше выражает эту концепцию, чем Java или C++:</p><p>Объект <code class="language-plaintext highlighter-rouge">photo</code> создается классом <code class="language-plaintext highlighter-rouge">File</code> (<code class="language-plaintext highlighter-rouge">new</code> является точкой входа в класс). После создания объект действует самостоятельно. Он не должен знать, кто его создал и сколько у него еще братьев и сестер в классе. Да, я имею в виду, что <a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">рефлексия</a> - ужасная идея, но я расскажу об этом подробнее в одном из следующих постов. А сейчас давайте поговорим о объектах и их лучших и худших сторонах.</p><p>Прежде всего, объект - это <strong>живой организм</strong>. Более того, объект должен быть <a href="https://ru.wikipedia.org/wiki/Антропоморфизм">антропоморфизирован</a>, то есть рассматриваться как человек (или домашнее животное, если вы их больше любите). Я имею в виду, что объект не является <em>структурой данных</em> или набором функций. Вместо этого он является самостоятельным существом со своим жизненным циклом, своим поведением и своими привычками.</p><p>Сотрудник, отдел, HTTP-запрос, таблица в MySQL, строка в файле или сам файл являются правильными объектами, потому что они существуют в реальной жизни, даже когда наше программное обеспечение выключено. Чтобы быть точнее, объект является <em>представителем</em> существа из реальной жизни. Это <em>прокси</em> этого существа перед всеми остальными объектами. Без такого существа, очевидно, нет объекта.</p><p>В этом примере я запрашиваю у <code class="language-plaintext highlighter-rouge">File</code> создание нового объекта <code class="language-plaintext highlighter-rouge">photo</code>, который будет представлять реальный файл на диске. Вы можете сказать, что файл также является чем-то виртуальным и существует только при включенном компьютере. Я соглашусь и уточню определение “реальной жизни” следующим образом: это все, что существует помимо программы, в которой живет объект. Дисковый файл находится за пределами области нашей программы; поэтому абсолютно правильно создать его представителя внутри программы.</p><p>Контроллер, парсер, фильтр, валидатор, сервис-локатор, синглтон или фабрика <strong>не являются</strong> хорошими объектами (да, большинство паттернов GoF - это анти-паттерны!). Они не существуют вне вашего программного обеспечения, в реальной жизни. Они придуманы только для связи других объектов. Они искусственные и фальшивые создания. Они никого не представляют. Правда, XML-парсер - кого он представляет? Никого.</p><p>Некоторые из них могут стать хорошими, если поменяют свои имена; другие никогда не смогут оправдать свое существование. Например, этот XML-парсер можно переименовать в “парсабельный XML” и начать представлять XML-документ, который существует за пределами нашей области.</p><p>Всегда задавайте себе вопрос: “Какая сущность реальной жизни стоит за моим объектом?” Если вы не можете найти ответ, начните думать о рефакторинге.</p><p>Хороший объект всегда работает по договорам. Он ожидает быть нанятым не из-за своих личных заслуг, а потому что он соблюдает договоры. С другой стороны, когда мы нанимаем объект, мы не должны дискриминировать и ожидать, что определенный объект из определенного класса выполнит работу за нас. Мы должны ожидать, что <em>любой</em> объект будет делать то, что говорит наш договор. Пока объект делает то, что нам нужно, нам не интересно его происхождение, пол или религия.</p><p>Например, мне нужно показать фотографию на экране. Я хочу, чтобы эта фотография была прочитана из файла в формате PNG. Я заключаю договор с объектом из класса <code class="language-plaintext highlighter-rouge">DataFile</code> и прошу его предоставить мне двоичное содержимое этого изображения.</p><p>Но подождите, я заботлюсь о том, откуда именно будет получено содержимое - из файла на диске, или из HTTP-запроса, или, может быть, из документа в Dropbox? На самом деле, нет. Мне важно только то, чтобы какой-то объект предоставил мне массив байтов с содержимым PNG. Итак, мой договор будет выглядеть так:</p><p>Теперь любой объект из любого класса (не только <code class="language-plaintext highlighter-rouge">DataFile</code>) может работать для меня. Ему просто нужно следовать договору - реализовывать интерфейс <code class="language-plaintext highlighter-rouge">Binary</code>.</p><p>Правило здесь простое: каждый публичный метод в хорошем объекте должен реализовывать своего аналога из интерфейса. Если ваш объект имеет публичные методы, которые не наследуются ни от одного интерфейса, значит, он плохо спроектирован.</p><p>Есть две практические причины для этого. Во-первых, объект, работающий без контракта, невозможно подменить в модульном тестировании. Во-вторых, объект без контракта невозможно расширить с помощью <a href="https://en.wikipedia.org/wiki/Decorator_pattern">декоратора</a>.</p><p>Хороший объект всегда должен инкапсулировать что-то, чтобы быть уникальным. Если нет ничего, что можно инкапсулировать, у объекта могут быть идентичные клонированные версии, что, на мой взгляд, является плохим. Вот пример плохого объекта, который может иметь клонированные версии:</p><p>Я могу создать несколько экземпляров класса <code class="language-plaintext highlighter-rouge">HTTPStatus</code>, и все они будут равны друг другу.</p><p>Очевидно, что утилитарные классы, которые имеют только статические методы, не могут создавать хорошие объекты. Более обще, утилитарные классы не обладают никакими достоинствами, упомянутыми в этой статье, и даже не могут называться “классами”. Они являются лишь ужасными нарушителями объектной парадигмы и существуют в современных объектно-ориентированных языках только потому, что их создатели включили статические методы.</p><p>Хороший объект никогда не должен изменять свое инкапсулированное состояние. Помните, что объект представляет собой сущность из реальной жизни, и эта сущность должна оставаться неизменной на протяжении всей жизни объекта. Другими словами, объект никогда не должен предавать тех, кого он представляет. Он никогда не должен менять владельцев.</p><p>Имейте в виду, что неизменяемость не означает, что все методы всегда возвращают одни и те же значения. Вместо этого, хороший неизменяемый объект очень динамичен. Однако он никогда не изменяет свое внутреннее состояние. Например:</p><p>Несмотря на то, что метод <code class="language-plaintext highlighter-rouge">read()</code> может возвращать разные значения, объект является неизменным. Он указывает на определенную веб-страницу и никогда не будет указывать куда-либо еще. Он никогда не изменит свое инкапсулированное состояние и никогда не предаст URL, который он представляет.</p><p>Почему неизменяемость является достоинством? Эта статья подробно объясняет: Объекты должны быть неизменяемыми. Вкратце, неизменяемые объекты лучше, потому что:</p><ul> <li><p>Действительно неизменяемые объекты всегда являются потокобезопасными.</p></li> <li><p>Они помогают избегать временной связности.</p></li> <li><p>Их использование не вызывает побочных эффектов (нет защитных копий).</p></li> <li><p>Они всегда обладают атомарностью отказа.</p></li> <li><p>Они гораздо проще кэшировать.</p></li> <li><p>Они предотвращают NULL-ссылки.</p></li></ul><p>Конечно же, у хорошего объекта не должно быть сеттеров, которые могут изменить его состояние и заставить его нарушить URL. Другими словами, введение метода <code class="language-plaintext highlighter-rouge">setURL()</code> было бы ужасной ошибкой в классе <code class="language-plaintext highlighter-rouge">HTTPStatus</code>.</p><p>Кроме всего прочего, неизменяемые объекты заставят вас создавать более связанные, прочные и понятные конструкции, как объясняется в статье: Как помогает неизменяемость.</p><p>Статический метод реализует поведение класса, а не объекта. Допустим, у нас есть класс <code class="language-plaintext highlighter-rouge">File</code>, и его дочерние классы имеют метод <code class="language-plaintext highlighter-rouge">size()</code>:</p><p>Пока все идет хорошо; метод <code class="language-plaintext highlighter-rouge">size()</code> присутствует из-за контракта <code class="language-plaintext highlighter-rouge">Measurable</code>, и каждый объект класса <code class="language-plaintext highlighter-rouge">File</code> сможет измерить свой размер. Ужасной ошибкой было бы разработать этот класс с использованием статического метода вместо этого (этот дизайн также известен как утилитарный класс и очень популярен в Java, Ruby и практически в каждом ООП-языке).</p><p>Этот дизайн полностью противоречит объектно-ориентированной парадигме. Почему? Потому что статические методы превращают объектно-ориентированное программирование в “класс-ориентированное” программирование. Этот метод <code class="language-plaintext highlighter-rouge">size()</code> предоставляет поведение класса, а не его объектов. Что в этом не так, вы можете спросить? Почему мы не можем иметь объекты и классы как граждан первого класса в нашем коде? Почему у них не может быть методов и свойств?</p><p>Проблема в том, что с класс-ориентированным программированием декомпозиция больше не работает. Мы не можем разбить сложную проблему на части, потому что во всей программе существует только один экземпляр класса. Сила ООП заключается в том, что она позволяет использовать объекты в качестве инструмента для декомпозиции области действия. Когда я создаю экземпляр объекта внутри метода, он предназначен для моей конкретной задачи. Он полностью изолирован от всех других объектов вокруг метода. Этот объект является <em>локальной переменной</em> в области действия метода. Класс с его статическими методами всегда является <em>глобальной переменной</em>, независимо от того, где я его использую. Из-за этого я не могу изолировать взаимодействие с этой переменной от других.</p><p>Помимо того, что понятийно противоречат принципам объектно-ориентированного программирования, публичные статические методы имеют несколько практических недостатков:</p><p>Во-первых, их <strong>невозможно замокать</strong> (Хорошо, можно использовать <a href="https://code.google.com/p/powermock/">PowerMock</a>, но это будет самым ужасным решением, которое можно принять в проекте на Java… Я сделал это однажды, несколько лет назад).</p><p>Во-вторых, они <strong>не являются потокобезопасными</strong> по определению, потому что они всегда работают со статическими переменными, которые доступны из всех потоков. Можно сделать их потокобезопасными, но для этого всегда требуется явная синхронизация.</p><p>Каждый раз, когда вы видите публичный статический метод, начинайте переписывать его сразу же. Я даже не хочу упоминать, насколько ужасны статические (или глобальные) переменные. Я думаю, это просто очевидно.</p><p>Название объекта должно говорить нам, <strong>что он есть</strong>, а не то, <strong>что он делает</strong>, так же как мы называем предметы в реальной жизни: книга вместо сборщика страниц, чашка вместо держателя воды, футболка вместо одевателя. Конечно, есть исключения, например, принтер или компьютер, но они были изобретены недавно и теми, кто не читал эту статью.</p><p>Например, эти названия говорят нам, кто их владельцы: яблоко, файл, серия HTTP-запросов, сокет, XML-документ, список пользователей, регулярное выражение, целое число, таблица PostgreSQL или Джеффри Лебовски. Надлежаще названный объект всегда можно нарисовать в виде небольшой картинки. Даже регулярное выражение можно нарисовать.</p><p>Наоборот, вот примеры названий, которые говорят нам, что делают их владельцы: считыватель файла, парсер текста, проверяющий URL, печататель XML, локатор службы, синглтон, исполнитель скрипта или Java-программист. Можете нарисовать хоть одного из них? Нет, не можете. Эти названия не подходят для хороших объектов. Это ужасные названия, которые приводят к ужасному дизайну.</p><p>Вообще, избегайте названий, оканчивающихся на “-ер” - большинство из них плохие.</p><p>“Каков альтернатива <code class="language-plaintext highlighter-rouge">FileReader</code>?” - слышу, как вы спрашиваете. Какое было бы лучшее название? Давайте подумаем. У нас уже есть <code class="language-plaintext highlighter-rouge">File</code>, который является представителем реального файла на диске. Этот представитель недостаточно мощный для нас, потому что он не умеет считывать содержимое файла. Мы хотим создать более мощного, который будет обладать такой способностью. Как бы мы его назвали? Помните, название должно говорить, что он есть, а не что он делает. Что он есть? Он - файл с данными; не просто файл, как <code class="language-plaintext highlighter-rouge">File</code>, но более сложный, с данными. Так что насчет <code class="language-plaintext highlighter-rouge">FileWithData</code> или просто <code class="language-plaintext highlighter-rouge">DataFile</code>?</p><p>Та же логика должна быть применима к всем остальным названиям. Всегда думайте о <strong>том, что это</strong> вместо того, что он делает. Давайте давать вашим объектам реальные, значимые имена, а не должности.</p><p>Больше об этом в статье “Не создавайте объекты, которые оканчиваются на -ER”.</p><p>Хороший объект может быть либо финальным, либо абстрактным классом. <code class="language-plaintext highlighter-rouge">Финальный</code> класс - это класс, который нельзя расширить с помощью наследования. <code class="language-plaintext highlighter-rouge">Абстрактный</code> класс - это класс, экземпляры которого нельзя создавать. Проще говоря, класс должен либо сказать: “Ты никогда не сможешь сломать меня; Я для тебя черный ящик”, либо “Я уже сломан; Сначала почини меня, а потом используй”.</p><p>Нет ничего посередине. Финальный класс - это черный ящик, который нельзя изменить никакими средствами. Он работает так, как он работает, и ты либо используешь его, либо выбрасываешь. Нельзя создать другой класс, который будет наследовать его свойства. Это не разрешено из-за модификатора <code class="language-plaintext highlighter-rouge">final</code>. Единственный способ расширить такой финальный класс - это через декорирование его дочерних классов. Предположим, у меня есть класс <code class="language-plaintext highlighter-rouge">HTTPStatus</code> (см. выше), и я его не люблю. Хорошо, я его люблю, но он для меня недостаточно мощный. Я хочу, чтобы он выбрасывал исключение, если статус HTTP превышает 400. Я хочу, чтобы его метод <code class="language-plaintext highlighter-rouge">read()</code> делал больше, чем он делает сейчас. Традиционным способом будет расширение класса и перезапись его метода:</p><p>Почему это неправильно? Это очень неправильно, потому что мы рискуем нарушить логику всего родительского класса, переопределяя один из его методов. Помните, что после того, как мы переопределили метод <code class="language-plaintext highlighter-rouge">read()</code> в дочернем классе, все методы родительского класса начинают использовать его новую версию. Мы буквально внедряем новую “часть реализации” прямо в класс. Философски говоря, это нарушение.</p><p>С другой стороны, чтобы расширить финальный класс, вы должны рассматривать его как черный ящик и украшать его собственной реализацией (т.е. <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">шаблоном Декоратора</a>).</p><p>Убедитесь, что этот класс реализует тот же интерфейс, что и оригинальный: <code class="language-plaintext highlighter-rouge">Status</code>. Экземпляр <code class="language-plaintext highlighter-rouge">HTTPStatus</code> будет передаваться ему через конструктор и инкапсулироваться. Затем каждый вызов будет перехватываться и реализовываться по-разному, если необходимо. В этом дизайне мы рассматриваем исходный объект как черный ящик и никогда не трогаем его внутреннюю логику.</p><p>Если вы не используете ключевое слово <code class="language-plaintext highlighter-rouge">final</code>, любой (включая вас) сможет расширить класс и… оскорбить его :( Такой класс без <code class="language-plaintext highlighter-rouge">final</code> является плохим дизайном.</p><p>Абстрактный класс - это прямо противоположная ситуация - он говорит нам, что он неполный и мы не можем использовать его «как есть». Мы должны внедрить нашу собственную логику реализации в него, но только в тех местах, которые он позволяет нам трогать. Эти места явно помечены как <code class="language-plaintext highlighter-rouge">abstract</code> методы. Например, наш <code class="language-plaintext highlighter-rouge">HTTPStatus</code> может выглядеть так:</p><p>Как видите, класс не знает точно, как проверить код HTTP, и он ожидает, что мы внедрим эту логику через наследование и переопределение метода <code class="language-plaintext highlighter-rouge">isValid()</code>. Мы не собираемся оскорблять его этим наследованием, так как он защитил все остальные методы с помощью <code class="language-plaintext highlighter-rouge">final</code> (обратите внимание на модификаторы его методов). Таким образом, класс готов к нашему оскорблению и идеально защищен от него.</p><p>В заключение, ваш класс должен быть либо <code class="language-plaintext highlighter-rouge">final</code>, либо <code class="language-plaintext highlighter-rouge">abstract</code> - ничего промежуточного.</p><p>Обновление (апрель 2017): Если вы также согласны, что механизм наследования реализации - это зло, все ваши классы должны быть <code class="language-plaintext highlighter-rouge">final</code>.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/36 on 2023-11-17 at 13:19</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d7375766803"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
