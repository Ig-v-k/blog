<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="How Immutability Helps"/> <meta name="twitter:description" property="og:description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2014/11/07/how-immutability-helps.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?278749a84ec"/> <link rel="apple-touch-icon" href="/favicon.ico?278749a84ec"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?278749a84ec"/> <link rel="stylesheet" href="/css/icons.css?278749a84ec"/> <link rel="canonical" href="https://www.yegor256.com/ru/2014/11/07/how-immutability-helps.html" /> <title>How Immutability Helps</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">How Immutability Helps</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2014/11/07/how-immutability-helps.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>В нескольких недавних постах, включая “Getters/Setters. Evil. Period. Objects Should Be Immutable” и “Dependency Injection Containers are Code Polluters”, я универсально назвал все изменяемые объекты с “сеттерами” (методы объекта, начинающиеся с <code class="language-plaintext highlighter-rouge">set</code>) злом. Мои аргументы в основном были основаны на метафорах и абстрактных примерах. Однако, похоже, это не было достаточно убедительным для многих из вас — я получил несколько запросов с просьбой предоставить более конкретные и практические примеры.</p><p>Таким образом, чтобы продемонстрировать мое крайне отрицательное отношение к “изменяемости с помощью сеттеров”, я взял существующую библиотеку на языке Java <a href="http://commons.apache.org/proper/commons-email/">commons-email</a> от Apache и переработал ее по своему образу, без использования сеттеров и с учетом “объектного мышления”. Я выпустил свою библиотеку в рамках семейства <a href="http://www.jcabi.com">jcabi</a> - <a href="http://email.jcabi.com">jcabi-email</a>. Давайте посмотрим, какие преимущества мы получим от “чистого” объектно-ориентированного и неизменяемого подхода, без использования геттеров.</p><p>Вот как будет выглядеть ваш код, если вы отправите электронное письмо с помощью commons-email:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Email email = new SimpleEmail();
email.setHostName("smtp.googlemail.com");
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator("user", "pwd"));
email.setFrom("yegor256@gmail.com", "Yegor Bugayenko");
email.addTo("dude@jcabi.com");
email.setSubject("how are you?");
email.setMsg("Dude, how are you?");
email.send();
</code></pre></div></div><p>Вот как вы можете сделать то же самое с <a href="http://email.jcabi.com">jcabi-email</a>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Postman postman = new Postman.Default(
  new SMTP("smtp.googlemail.com", 465, "user", "pwd")
);
Envelope envelope = new Envelope.MIME(
  new Array&lt;Stamp&gt;(
    new StSender("Yegor Bugayenko &lt;yegor256@gmail.com&gt;"),
    new StRecipient("dude@jcabi.com"),
    new StSubject("how are you?")
  ),
  new Array&lt;Enclosure&gt;(
    new EnPlain("Dude, how are you?")
  )
);
postman.send(envelope);
</code></pre></div></div><p>Я думаю, разница очевидна.</p><p>В первом примере вы работаете с классом монстра, который может сделать все за вас, включая отправку вашего MIME-сообщения через SMTP, создание сообщения, настройку его параметров, добавление MIME-частей и т.д. Класс <a href="http://svn.apache.org/viewvc/commons/proper/email/tags/EMAIL_1_3_3/src/main/java/org/apache/commons/mail/Email.java?revision=1609295&amp;view=co"><code class="language-plaintext highlighter-rouge">Email</code></a> из библиотеки commons-email действительно огромный - 33 частных свойства, более сотни методов, около двух тысяч строк кода. Сначала вы настраиваете класс с помощью набора сеттеров, а затем просите его отправить электронное письмо для вас вызовом метода <code class="language-plaintext highlighter-rouge">send()</code>.</p><p>Во втором примере у нас есть семь объектов, созданных через семь вызовов <code class="language-plaintext highlighter-rouge">new</code>. <code class="language-plaintext highlighter-rouge">Postman</code> отвечает за упаковку сообщения MIME; <code class="language-plaintext highlighter-rouge">SMTP</code> отвечает за его отправку по протоколу SMTP; штампы (<code class="language-plaintext highlighter-rouge">StSender</code>, <code class="language-plaintext highlighter-rouge">StRecipient</code> и <code class="language-plaintext highlighter-rouge">StSubject</code>) отвечают за настройку сообщения MIME перед доставкой; вложение <code class="language-plaintext highlighter-rouge">EnPlain</code> отвечает за создание MIME-части для сообщения, которое мы собираемся отправить. Мы создаем эти семь объектов, инкапсулируя один в другой, а затем просим почтальона отправить конверт с помощью метода <code class="language-plaintext highlighter-rouge">send()</code>.</p><h2 id="whats-wrong-with-a-mutable-email">What’s Wrong With a Mutable Email?</h2><p>С точки зрения пользователя практически нет никаких проблем. <code class="language-plaintext highlighter-rouge">Email</code> является мощным классом с несколькими элементами управления — достаточно выбрать нужный, и задача будет выполнена. Однако, с точки зрения разработчика класс <code class="language-plaintext highlighter-rouge">Email</code> является кошмаром. В основном из-за его большого размера и сложности поддержки.</p><p><em>Поскольку класс настолько большой</em>, каждый раз, когда вы хотите расширить его, представив новый метод, вы сталкиваетесь с тем, что делаете класс еще хуже - длиннее, менее связанным, менее читаемым, менее поддерживаемым и т. д. У вас возникает чувство, что вы копаетесь в чем-то грязном и что нет никакой надежды сделать его чище, никогда. Я уверен, что вы знакомы с этим чувством - большинство старых приложений выглядят таким образом. Они имеют огромные многострочные “классы” (на самом деле, программы на COBOL, написанные на Java), которые были унаследованы от нескольких поколений программистов перед вами. Когда вы начинаете, вы полны энергии, но через несколько минут прокрутки такого “класса” вы говорите: “к черту, почти суббота”.</p><p><em>Из-за того, что класс настолько большой</em>, здесь больше нет сокрытия данных или инкапсуляции — 33 переменные доступны более чем 100 методам. Что скрыто? Этот файл <code class="language-plaintext highlighter-rouge">Email.java</code> на самом деле является большим процедурным сценарием из 2000 строк, который по ошибке называется “классом”. Ничто не скрыто, как только вы пересекаете границу класса, вызывая один из его методов. После этого вы имеете полный доступ ко всем данным, которые вам могут понадобиться. Почему это плохо? Что, во-первых, нам нужна инкапсуляция? Чтобы защитить одного программиста от другого, так называемое защитное программирование. Когда я занят изменением темы MIME-сообщения, я хочу быть уверенным, что меня не помешает деятельность какого-то другого метода, который случайно меняет отправителя и касается моей темы. Инкапсуляция помогает сузить область проблемы, тогда как этот класс <code class="language-plaintext highlighter-rouge">Email</code> делает в точности обратное.</p><p><em>Поскольку класс настолько большой</em>, его модульное тестирование еще сложнее, чем сам класс. Почему? Из-за множества взаимосвязей между его методами и свойствами. Чтобы протестировать <code class="language-plaintext highlighter-rouge">setCharset()</code>, вам нужно подготовить всей объект, вызвав несколько других методов, затем вызвать <code class="language-plaintext highlighter-rouge">send()</code>, чтобы убедиться, что отправляемое сообщение действительно использует кодировку, которую вы указали. Таким образом, чтобы протестировать однострочный метод <code class="language-plaintext highlighter-rouge">setCharset()</code>, вы запускаете полный сценарий интеграционного тестирования отправки полного MIME-сообщения через SMTP. Очевидно, что если что-то изменится в одном из методов, почти каждый тестовый метод будет затронут. Другими словами, тесты очень хрупкие, ненадежные и излишне сложные.</p><p>Я могу продолжать это “<em>потому что класс такой большой</em>,” но я думаю, что очевидно, что маленький, сплоченный класс всегда лучше большого. Это очевидно для меня, для вас и для любого объектно-ориентированного программиста. Но почему это не так очевидно для разработчиков Apache Commons Email? Я не думаю, что они глупые или необразованные. Что же это?</p><h2 id="how-and-why-did-it-happen">How and Why Did It Happen?</h2><p>Вот как это всегда происходит. Вы начинаете проектировать класс как нечто объединенное, прочное и небольшое. Ваши намерения очень положительные. Очень скоро вы понимаете, что есть еще что-то, что этот класс должен делать. Затем что-то еще. Затем еще больше.</p><p>Лучший способ сделать ваш класс более и более мощным - это добавить сеттеры, которые внедряют конфигурационные параметры в класс, чтобы он мог обрабатывать их внутри, не так ли?</p><p>Это корневая причина проблемы! Корневая причина заключается в нашей способности <em>вставлять</em> данные в изменяемые объекты с помощью методов конфигурации, также известных как «сеттеры». Когда объект является изменяемым и позволяет нам добавлять сеттеры в любое время, мы будем делать это без ограничений.</p><p>Позвольте мне сказать по-другому - <em>изменяемые классы обычно увеличиваются в размере и теряют связность</em>.</p><p>Если бы авторы библиотеки commons-email сделали класс <code class="language-plaintext highlighter-rouge">Email</code> неизменяемым с самого начала, они бы не смогли добавить в него так много методов и инкапсулировать столько свойств. Они не смогли бы превратить его в монстра. Почему? Потому что неизменяемый объект принимает состояние только через конструктор. Можете ли вы представить себе конструктор с 33 аргументами? Конечно, нет.</p><p>Когда вы создаете свой класс неизменяемым изначально, вы вынуждены сохранять его связность, компактность, надежность и устойчивость. Поскольку вы не можете инкапсулировать слишком много и изменять то, что инкапсулировано. Просто два или три аргумента конструктора, и вы закончили.</p><h2 id="how-did-i-design-an-immutable-email">How Did I Design An Immutable Email?</h2><p>Когда я разрабатывал <a href="https://github.com/jcabi/jcabi-email">jcabi-email</a>, я начал с небольшого и простого класса: <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>. Ну, на самом деле, это интерфейс, так как я никогда не создаю классы без интерфейса. Итак, <code class="language-plaintext highlighter-rouge">Postman</code> - это… почтальон. Он доставляет сообщения другим людям. Сначала я создал его стандартную версию (я опускаю конструктор для краткости):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import javax.mail.Message;
@Immutable
class Postman.Default implements Postman {
  private final String host;
  private final int port;
  private final String user;
  private final String password;
  @Override
  void send(Message msg) {
    // create SMTP session
    // create transport
    // transport.connect(this.host, this.port, etc.)
    // transport.send(msg)
    // transport.close();
  }
}
</code></pre></div></div><p>Хороший старт, работает. Что теперь? Ну, <a href="http://docs.oracle.com/javaee/7/api/javax/jms/Message.html"><code class="language-plaintext highlighter-rouge">Message</code></a> трудно создать. Это сложный класс из JDK, который требует некоторых манипуляций, прежде чем он сможет стать красивым HTML-письмом. Поэтому я создал конверт, который будет создавать этот сложный объект за меня (обратите внимание, и <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>, и <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">Envelope</code></a> являются неизменяемыми и помечены аннотацией <a href="http://aspects.jcabi.com/apidocs-0.20/com/jcabi/aspects/Immutable.html">@Immutable</a> из <a href="http://aspects.jcabi.com/annotation-immutable.html">jcabi-aspects</a>).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Envelope {
  Message unwrap();
}
</code></pre></div></div><p>Я также провожу рефакторинг <code class="language-plaintext highlighter-rouge">Postman</code>, чтобы он принимал конверт, а не сообщение.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Postman {
  void send(Envelope env);
}
</code></pre></div></div><p>Пока все идет хорошо. Теперь попробуем создать простую реализацию <code class="language-plaintext highlighter-rouge">Envelope</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class MIME implements Envelope {
  @Override
  public Message unwrap() {
    return new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
  }
}
</code></pre></div></div><p>Он работает, но еще ничего полезного не делает. Он только создает абсолютно пустое MIME-сообщение и возвращает его. Как насчет добавления темы к нему и адресов <code class="language-plaintext highlighter-rouge">To:</code> и <code class="language-plaintext highlighter-rouge">From:</code> (обратите внимание, что класс <a href="http://email.jcabi.com/apidocs-1.10/com/jcabi/email/Envelope.Mime.html"><code class="language-plaintext highlighter-rouge">MIME</code></a> также является неизменяемым)?</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Envelope.MIME implements Envelope {
  private final String subject;
  private final String from;
  private final Array&lt;String&gt; to;
  public MIME(String subj, String sender, Iterable&lt;String&gt; rcpts) {
    this.subject = subj;
    this.from = sender;
    this.to = new Array&lt;String&gt;(rcpts);
  }
  @Override
  public Message unwrap() {
    Message msg = new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
    msg.setSubject(this.subject);
    msg.setFrom(new InternetAddress(this.from));
    for (String email : this.to) {
      msg.setRecipient(
        Message.RecipientType.TO,
        new InternetAddress(email)
      );
    }
    return msg;
  }
}
</code></pre></div></div><p>Выглядит правильно и работает. Но это все еще слишком примитивно. Как насчет «Копия» (<code class="language-plaintext highlighter-rouge">CC:</code>) и «Скрытая копия» (<code class="language-plaintext highlighter-rouge">BCC:</code>)? Что насчет текста электронной почты? Как насчет вложений в формате PDF? Что, если я хочу указать кодировку сообщения? Как насчет «Ответить» (<code class="language-plaintext highlighter-rouge">Reply-To</code>)?</p><p>Можно ли добавить все эти параметры в конструктор? Помните, что класс является неизменяемым, и я не могу внести метод <code class="language-plaintext highlighter-rouge">setReplyTo()</code>. Мне нужно передать аргумент <code class="language-plaintext highlighter-rouge">replyTo</code> в его конструктор. Это невозможно, так как конструктор будет иметь слишком много аргументов, и никто не сможет его использовать.</p><p>So, what do I do?</p><p>Ну, я стал задумываться: как мы можем разделить понятие “конверта” на более мелкие понятия, и вот что я придумал. Как и настоящий конверт, мой объект <code class="language-plaintext highlighter-rouge">MIME</code> будет иметь марки. Марки будут отвечать за настройку объекта <code class="language-plaintext highlighter-rouge">Message</code> (опять же, <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Stamp.java"><code class="language-plaintext highlighter-rouge">Stamp</code></a> является неизменяемым, также как и все его реализаторы):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Stamp {
  void attach(Message message);
}
</code></pre></div></div><p>Теперь я могу упростить мой класс <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">MIME</code></a> до следующего:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Envelope.MIME implements Envelope {
  private final Array&lt;Stamp&gt; stamps;
  public MIME(Iterable&lt;Stamp&gt; stmps) {
    this.stamps = new Array&lt;Stamp&gt;(stmps);
  }
  @Override
  public Message unwrap() {
    Message msg = new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
    for (Stamp stamp : this.stamps) {
      stamp.attach(msg);
    }
    return msg;
  }
}
</code></pre></div></div><p>Теперь я создам штампы для темы, для «Кому:», для «От кого:», для «Копия:», для «Скрытая копия:» и т. д. Столько штампов, сколько мне нужно. Класс <code class="language-plaintext highlighter-rouge">MIME</code> останется тем же - небольшим, согласованным, читаемым, надежным и т. д.</p><p>Важно здесь понять, почему я принял решение провести рефакторинг, когда класс был еще относительно маленьким. Действительно, я начал беспокоиться о классах-штампах, когда мой класс <code class="language-plaintext highlighter-rouge">MIME</code> состоял всего из 25 строк.</p><p>Это и является главной целью данной статьи - <em>неизменяемость заставляет вас проектировать небольшие и согласованные объекты</em>.</p><p>Без неизменяемости я пошел бы по тому же пути, что и commons-email. Мой класс <code class="language-plaintext highlighter-rouge">MIME</code> стал бы все больше и рано или поздно стал бы таким же большим, как <code class="language-plaintext highlighter-rouge">Email</code> из commons-email. Единственное, что остановило меня, это необходимость провести рефакторинг, поскольку я не мог передать все аргументы через конструктор.</p><p>Без неизменности, у меня не было бы этого стимула, и я бы сделал то же, что и разработчики Apache с commons-email — расширил класс и превратил его в неподдерживаемое чудовище.</p><p>Это <a href="http://email.jcabi.com">jcabi-email</a>. Я надеюсь, что этот пример был достаточно иллюстративным и что вы начнете писать более чистый код с неизменяемыми объектами.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-15 at 15:09</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?278749a84ec"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
