<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Object state and behavior are two very different things, and confusing the two often leads to incorrect design." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="How an Immutable Object Can Have State and Behavior?"/> <meta name="twitter:description" property="og:description" content="Object state and behavior are two very different things, and confusing the two often leads to incorrect design."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2014/12/09/immutable-object-state-and-behavior.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?1140ffc17a1"/> <link rel="apple-touch-icon" href="/favicon.ico?1140ffc17a1"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?1140ffc17a1"/> <link rel="stylesheet" href="/css/icons.css?1140ffc17a1"/> <link rel="canonical" href="https://www.yegor256.com/ru/2014/12/09/immutable-object-state-and-behavior.html" /> <title>How an Immutable Object Can Have State and Behavior?</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">How an Immutable Object Can Have State and Behavior?</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2014/12/09/immutable-object-state-and-behavior.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Я часто слышу этот аргумент против неизменяемых объектов: “Да, они полезны, когда состояние не меняется. Однако в нашем случае мы имеем дело с часто изменяющимися объектами. Просто нам не по карману создавать новый <code class="language-plaintext highlighter-rouge">document</code> каждый раз, когда мы хотим изменить его <code class="language-plaintext highlighter-rouge">title</code>.” Вот где я не согласен: заголовок объекта - это <strong>не состояние</strong> документа, если вам часто нужно его изменять. Вместо этого, это <strong>поведение</strong> документа. <code class="language-plaintext highlighter-rouge">Document</code> может и должен быть неизменяемым, если он хороший объект, даже если его заголовок часто изменяется. Позвольте мне объяснить, как это работает.</p><h2 id="identity-state-and-behavior">Identity, State, and Behavior</h2><p>В основе каждого объекта лежат три элемента: идентичность, состояние и поведение. <em>Идентичность</em> - это то, что отличает наш <code class="language-plaintext highlighter-rouge">документ</code> от других объектов, <em>состояние</em> - это то, что документ знает о себе (также известно как “инкапсулированное знание”), и <em>поведение</em> - это то, что документ может делать по нашему запросу. Например, этот документ является изменяемым:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Document {
  private int id;
  private String title;
  Document(int id) {
    this.id = id;
  }
  public String getTitle() {
    return this.title;
  }
  public String setTitle(String text) {
    this.title = text;
  }
  @Override
  public String toString() {
    return String.format("doc #%d about '%s'", this.id, this.text);
  }
}
</code></pre></div></div><p>Давайте попробуем использовать этот изменяемый объект:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Document first = new Document(50);
first.setTitle("How to grill a sandwich");
Document second = new Document(50);
second.setTitle("How to grill a sandwich");
if (first.equals(second)) { // FALSE
  System.out.println(
    String.format("%s is equal to %s", first, second)
  );
}
</code></pre></div></div><p>Здесь мы создаем два объекта и затем изменяем их инкапсулированные состояния. Очевидно, что <code class="language-plaintext highlighter-rouge">first.equals(second)</code> вернет <code class="language-plaintext highlighter-rouge">false</code>, потому что у двух объектов разные идентичности, даже если они инкапсулируют одно и то же состояние.</p><p>Метод <code class="language-plaintext highlighter-rouge">toString()</code> отображает поведение документа — документ может преобразовать себя в строку.</p><p>Чтобы изменить заголовок документа, мы просто вызываем его <code class="language-plaintext highlighter-rouge">setTitle()</code> еще раз:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>first.setTitle("How to cook pasta");
</code></pre></div></div><p>Проще говоря, мы можем многократно использовать объект, изменяя его внутреннее состояние. Это быстро и удобно, не так ли? Быстро - да. Удобно - не совсем. Читайте дальше.</p><h2 id="immutable-objects-have-no-identity">Immutable Objects Have No Identity</h2><p>Как я уже упоминал ранее, неизменяемость является одной из достоинств хорошего объекта, и очень важной. Хороший объект неизменяем, а хорошее программное обеспечение содержит только неизменяемые объекты. Основное отличие между неизменяемыми и изменяемыми объектами заключается в том, что у неизменяемого объекта нет идентичности, и его состояние никогда не меняется. Вот неизменяемая версия того же документа:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Document {
  private final int id;
  private final String title;
  Document(int id, String text) {
    this.id = id;
    this.title = text;
  }
  public String title() {
    return this.title;
  }
  public Document title(String text) {
    return new Document(this.id, text);
  }
  @Override
  public boolean equals(Object doc) {
    return doc instanceof Document
      &amp;&amp; Document.class.cast(doc).id == this.id
      &amp;&amp; Document.class.cast(doc).title.equals(this.title);
  }
  @Override
  public String toString() {
    return String.format(
      "doc #%d about '%s'", this.id, this.text
    );
  }
}
</code></pre></div></div><p>Этот документ является неизменным, и его состояние (<code class="language-plaintext highlighter-rouge">id</code> и <code class="language-plaintext highlighter-rouge">title</code>) является его идентификатором. Давайте посмотрим, как мы можем использовать этот неизменяемый класс (кстати, я использую аннотацию <a href="http://aspects.jcabi.com/annotation-immutable.html"><code class="language-plaintext highlighter-rouge">@Immutable</code></a> из <a href="http://aspects.jcabi.com">jcabi-aspects</a>).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Document first = new Document(50, "How to grill a sandwich");
Document second = new Document(50, "How to grill a sandwich");
if (first.equals(second)) { // TRUE
  System.out.println(
    String.format("%s is equal to %s", first, second)
  );
}
</code></pre></div></div><p>Мы больше не можем изменять документ. Когда нам нужно изменить заголовок, мы должны создать новый документ.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Document first = new Document(50, "How to grill a sandwich");
first = first.title("How to cook pasta");
</code></pre></div></div><p>Каждый раз, когда мы хотим изменить его инкапсулированное состояние, мы также должны изменить его идентичность, потому что здесь нет идентичности. Состояние - это идентичность. Посмотрите на код метода <code class="language-plaintext highlighter-rouge">equals()</code>, приведенного выше - он сравнивает документы по их идентификаторам и заголовкам. Теперь идентичность документа - это его идентификатор + заголовок!</p><h2 id="what-about-frequent-changes">What About Frequent Changes?</h2><p>Теперь я перейду к вопросу, с которого мы начали: что насчет производительности и удобства? Мы не хотим изменять весь документ каждый раз, когда нам нужно изменить его заголовок. Если документ достаточно большой, это будет огромной обязанностью. Более того, если неизменяемый объект инкапсулирует другие неизменяемые объекты, нам придется изменять всю иерархию, даже если изменяется только одна строка в одном из них.</p><p>Ответ прост: заголовок документа не должен быть частью его <strong>состояния</strong>. Вместо этого заголовок должен быть его <strong>поведением</strong>. Например, рассмотрим следующий пример:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Document {
  private final int id;
  Document(int id) {
    this.id = id;
  }
  public String title() {
    // read title from storage
  }
  public void title(String text) {
    // save text to storage
  }
  @Override
  public boolean equals(Object doc) {
    return doc instanceof Document
      &amp;&amp; Document.class.cast(doc).id == this.id;
  }
  @Override
  public String toString() {
    return String.format("doc #%d about '%s'", this.id, this.title());
  }
}
</code></pre></div></div><p>С концептуальной точки зрения, данный документ выступает в качестве прокси реального документа, у которого заголовок хранится где-то - например, в файле. Это то, что хороший объект должен делать - быть прокси реальной сущности. Документ предоставляет две функции: чтение заголовка и сохранение заголовка. Вот как будет выглядеть его интерфейс:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Document {
  String title();
  void title(String text);
}
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">title()</code> reads the title of the document and returns it as a <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">title(String)</code> saves it back into the document. Imagine a real paper document with a title. You ask an object to read that title from the paper or to erase an existing one and write new text over it. This paper is a “copy” utilized in these methods.</p><p>Теперь мы можем вносить частые изменения в неизменяемый документ, и документ остается таким же. Он не перестает быть неизменяемым, поскольку его состояние (<code class="language-plaintext highlighter-rouge">id</code>) не изменяется. Это тот же документ, даже если мы меняем его заголовок, потому что заголовок не является состоянием документа. Это что-то в реальном мире, вне документа. Документ является всего лишь прокси между нами и этим “чем-то”. Чтение и запись заголовка <em>представляют собой поведение</em> документа, а не его состояние.</p><h2 id="mutable-memory">Mutable Memory</h2><p>Единственный вопрос, на который мы все еще не имеем ответа, - что такое “копия” и что произойдет, если нам нужно сохранить название документа в памяти?</p><p>Давайте рассмотрим это с точки зрения “объектного мышления”. У нас есть объект <code class="language-plaintext highlighter-rouge">document</code>, который предполагается представлять реальную сущность в объектно-ориентированном мире. Если такая сущность является файлом, мы легко можем реализовать методы <code class="language-plaintext highlighter-rouge">title()</code>. Если такая сущность является объектом Amazon S3, мы также легко реализуем методы чтения и записи названия, сохраняя объект неизменным. Если такая сущность является веб-страницей HTTP, у нас нет проблем с реализацией методов чтения или записи названия, сохраняя объект неизменным. У нас нет проблем, пока существует реальный документ и у него есть своя собственная идентичность. Наши методы чтения и записи названия будут взаимодействовать с этим реальным документом и извлекать или обновлять его название.</p><p>Проблемы возникают, когда такая сущность не существует в реальном мире. В этом случае нам нужно создать изменяемое свойство объекта с названием <code class="language-plaintext highlighter-rouge">title</code>, читать его с помощью <code class="language-plaintext highlighter-rouge">title()</code>, и изменять с помощью <code class="language-plaintext highlighter-rouge">title(String)</code>. Но объект является неизменным, поэтому мы не можем иметь изменяемое свойство в нем - по определению! Что же делать?</p><p>Think.</p><p>Как это может быть, что наш объект не представляет собой сущность реального мира? Помните, что <em>реальный мир</em> - это все, что окружает живую среду объекта. Возможно ли, что объект не представляет никого и действует самостоятельно? Нет, это невозможно. Каждый объект является представителем сущности реального мира. Так кого же он представляет, если мы хотим сохранить <code class="language-plaintext highlighter-rouge">title</code> внутри него и у нас нет файла или HTTP-страницы за объектом?</p><p>Он представляет <em>компьютерную память</em>.</p><p>Заголовок неизменяемого документа № 50 “Как приготовить гриль-сэндвич” хранится в памяти и занимает 23 байта пространства. Документ должен знать, где хранятся эти байты, и должен иметь возможность их прочитать и заменить на что-то другое. Эти 23 байта - это сущность реального мира, которую представляет объект. Байты не имеют никакого отношения к состоянию объекта. Они являются <em>изменяемой</em> сущностью реального мира, подобной файлу, HTTP-странице или объекту Amazon S3.</p><p>К сожалению, Java (и многие другие современные языки) не позволяют прямого доступа к компьютерной памяти. Вот как мы бы разработали наш класс, если бы такой прямой доступ был возможен:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Document {
  private final int id;
  private final Memory memory;
  Document(int id) {
    this.id = id;
    this.memory = new Memory();
  }
  public String title() {
    return new String(this.memory.read());
  }
  public void title(String text) {
    this.memory.write(text.getBytes());
  }
}
</code></pre></div></div><p>Этот класс <code class="language-plaintext highlighter-rouge">Memory</code> будет реализован нативно в JDK, а все остальные классы будут неизменяемыми. Класс <code class="language-plaintext highlighter-rouge">Memory</code> будет иметь прямой доступ к куче памяти и будет отвечать за операции <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation"><code class="language-plaintext highlighter-rouge">malloc</code> и <code class="language-plaintext highlighter-rouge">free</code></a> на уровне операционной системы. Имея такой класс, мы сможем сделать все классы Java неизменяемыми, включая <code class="language-plaintext highlighter-rouge">StringBuffer</code>, <code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code> и т.д.</p><p>Класс <code class="language-plaintext highlighter-rouge">Memory</code> будет явно подчеркивать миссию объекта в программе, которая заключается в том, чтобы быть <em>аниматором данных</em>. Объект не хранит данные; он анимирует их. Данные существуют где-то и являются анемичными, статичными, неподвижными и т.д. Данные <strong>мертвы</strong>, пока объект <strong>жив</strong>. Роль объекта - оживить кусок данных, <em>анимировать</em> его, но не стать самим куском данных. Объекту необходимо некоторое знание, чтобы получить доступ к этому мёртвому куску данных. Объект может понадобиться уникальный ключ из базы данных, адрес HTTP, имя файла или адрес памяти, чтобы найти данные и анимировать их. Но объект никогда не должен считать себя данными.</p><h2 id="what-is-the-practical-solution">What Is the Practical Solution?</h2><p>К сожалению, в языках программирования Java, Ruby, JavaScript, Python, PHP и многих других высокоуровневых языках нет такого класса, который бы представлял память. Кажется, разработчики языков не уловили идею живых объектов по сравнению с мертвыми данными, что печально. Нам приходится смешивать данные с состоянием объектов с использованием одних и тех же конструкций языка: переменных и свойств объектов. Может быть, когда-нибудь у нас появится класс <code class="language-plaintext highlighter-rouge">Memory</code> в Java и других языках, но пока у нас есть несколько вариантов.</p><p><strong>Использовать C++</strong>. В C++ и подобных низкоуровневых языках можно получить прямой доступ к памяти и работать с данными в памяти так же, как с данными в файле или в HTTP. В C++ мы можем создать класс <code class="language-plaintext highlighter-rouge">Memory</code> и использовать его точно так, как мы объяснили выше.</p><p><strong>Использовать массивы</strong>. В Java массив является структурой данных с уникальным свойством — его можно изменять, даже если он объявлен как <code class="language-plaintext highlighter-rouge">final</code>. Вы можете использовать массив байтов как изменяемую структуру данных внутри неизменяемого объекта. Это временное решение, которое концептуально напоминает класс <code class="language-plaintext highlighter-rouge">Memory</code>, но является более примитивным.</p><p><strong>Избегать данных в памяти</strong>. Старайтесь избегать данных в памяти насколько это возможно. В некоторых областях это легко сделать; например, в веб-приложениях, обработке файлов, адаптерах ввода-вывода и т.д. Однако в других областях это гораздо сложнее. Например, в играх, алгоритмах обработки данных и графическом интерфейсе большинство объектов анимируют данные в памяти в основном потому, что память является их единственным ресурсом. В этом случае, без класса <code class="language-plaintext highlighter-rouge">Memory</code>, вы оказываетесь с изменяемыми объектами :( Нет обходного пути.</p><p>В заключение, не забывайте, что объект является <strong>аниматором</strong> данных. Он использует свои инкапсулированные знания, чтобы обратиться к данным. Независимо от того, где данные хранятся - в файле, в HTTP или в памяти - концептуально они очень отличаются от состояния объекта, даже если они могут выглядеть очень похожими.</p><p>Хороший объект - это неизменяемый аниматор изменяемых данных. Несмотря на то, что объект является неизменяемым, а данные изменяемыми, он остается живым, а данные мертвыми в рамках жизненной среды объекта.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/36 on 2023-10-12 at 16:27</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?1140ffc17a1"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
