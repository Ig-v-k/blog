<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="It is a platform-independent object repository, which hosts source code and validates its consistency on each modification." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Objectionary: Dictionary and Factory for EO Objects"/> <meta name="twitter:description" property="og:description" content="It is a platform-independent object repository, which hosts source code and validates its consistency on each modification."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2021/10/21/objectionary.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?15ff2847650"/> <link rel="apple-touch-icon" href="/favicon.ico?15ff2847650"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?15ff2847650"/> <link rel="stylesheet" href="/css/icons.css?15ff2847650"/> <link rel="canonical" href="https://www.yegor256.com/ru/2021/10/21/objectionary.html" /> <title>Objectionary: Dictionary and Factory for EO Objects</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;386</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Objectionary: Dictionary and Factory for EO Objects</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2021/10/21/objectionary.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Со времен Кернигана и Ритчи мы делимся бинарным кодом в библиотеках. Вам нужно вывести некоторый текст с помощью <a href="https://en.wikipedia.org/wiki/Printf_format_string"><code class="language-plaintext highlighter-rouge">printf()</code></a> в C++? Вы получаете библиотеку <a href="https://en.wikipedia.org/wiki/Glibc">libc</a> с более чем <a href="https://stackoverflow.com/a/33188344/187141">700</a> другими функциями внутри. Вам нужно скопировать поток в Java? Вы получаете <a href="https://commons.apache.org/proper/commons-io/">Apache Commons IO</a> с методом <a href="https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html#copy-java.io.InputStream-java.io.OutputStream-"><code class="language-plaintext highlighter-rouge">copy()</code></a> и более чем <a href="https://commons.apache.org/proper/commons-io/apidocs/index.html">140</a> другими методами и классами. То же самое происходит во всех языках, о которых я знаю, таких как Ruby, Python, JavaScript, PHP: вам нужен объект, класс, функция или метод - вы должны добавить всю библиотеку в свою сборку. Не было бы это более элегантным обрабатывать отдельные объекты вместо этого?</p><p>Идея не нова и не моя. Я получил ее из книги <a href="http://amzn.to/266oJr4">Object Thinking</a> Дэвида Уэста, где он предложил создать <em>Объектарий</em> (стр. 306), “комбинацию словаря и объектной фабрики”, с следующими свойствами:</p><ul> <li><p>Общее количество объектов составляет менее 2000.</p></li> <li><p>Каждый объект является автономной исполняемой сущностью.</p></li> <li><p>Каждый объект имеет уникальный идентификатор и уникальный “адрес”.</p></li> <li><p>Объекты - это всего лишь коллекции объектов;</p></li> <li><p>Объекты требуют виртуальных машин, специфичных для аппаратного обеспечения, для выполнения.</p></li></ul><p>Семнадцать лет спустя (книга была опубликована в 2004 году) мы реализовали идею поверх <a href="https://www.eolang.org">EO</a>, нашего нового языка программирования. Язык намеренно гораздо проще, чем Java или C++. Вы можете прочитать его более или менее формальное описание <a href="https://arxiv.org/abs/2111.13384">здесь</a>.</p><p>Чтобы превратить программу EO в исполняемый объект и выпустить ее в <a href="https://www.objectionary.com">Objectionary</a>, необходимо пройти через следующие обязательные шаги, предполагая, что JVM используется в качестве целевой платформы (шаги, отмеченные символом 🌵, реализуются нашим <a href="https://github.com/cqfn/eo">eo-maven-plugin</a>):</p><ul> <li><p><strong>Assemble</strong>🌵:</p></li> <li><p><strong>Разбор</strong>🌵: <code class="language-plaintext highlighter-rouge">.eo</code> ➜ <code class="language-plaintext highlighter-rouge">.xmir</code></p></li> <li><p><strong>Оптимизировать</strong>🌵: <code class="language-plaintext highlighter-rouge">.xmir</code> ➜ лучше <code class="language-plaintext highlighter-rouge">.xmir</code></p></li> <li><p><strong>Обнаружение</strong>🌵: поиск всех иностранных псевдонимов</p></li> <li><p><strong>Pull</strong>🌵: <a href="https://github.com/yegor256/objectionary">download</a> foreign <code class="language-plaintext highlighter-rouge">.eo</code> objects</p></li></ul><p><strong>Получить</strong>🌵: <a href="https://github.com/yegor256/objectionary">скачать</a> внешние объекты <code class="language-plaintext highlighter-rouge">.eo</code></p><ul> <li><p><strong>Разрешить</strong>🌵: <a href="https://search.maven.org/">скачать</a> и распаковать артефакты <code class="language-plaintext highlighter-rouge">.jar</code></p></li> <li><p><strong>Место</strong>🌵: переместите артефактные файлы <code class="language-plaintext highlighter-rouge">.class</code> в <code class="language-plaintext highlighter-rouge">target/classes/</code>.</p></li> <li><p><strong>Марк</strong>🌵: пометить исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code>, найденные в <code class="language-plaintext highlighter-rouge">.jar</code>, как иностранные.</p></li> <li><p>↑ Вернитесь к <strong>Parse</strong>, если некоторые файлы <code class="language-plaintext highlighter-rouge">.eo</code> все еще не разобраны</p></li> <li><p><strong>Транспиляция</strong>🌵: <code class="language-plaintext highlighter-rouge">.xmir</code> ➜ <code class="language-plaintext highlighter-rouge">.java</code></p></li> <li><p>“<strong>Assemble</strong>🌵: same as above, but for tests” can be translated to Russian as: “<strong>Assemble</strong>🌵: то же самое, что и выше, но для тестов”.</p></li> <li><p><strong>Компиляция</strong>: <code class="language-plaintext highlighter-rouge">.java</code> ➜ <code class="language-plaintext highlighter-rouge">.class</code></p></li> <li><p><strong>Тест</strong>: запустить все модульные тесты.</p></li> <li><p><strong>Unplace</strong>🌵: удаление файлов <code class="language-plaintext highlighter-rouge">.class</code> артефактов</p></li> <li><p><strong>Unspile</strong>🌵: удаление автоматически созданных файлов <code class="language-plaintext highlighter-rouge">.java</code></p></li> <li><p><strong>Копирование</strong>🌵: скопируйте файлы <code class="language-plaintext highlighter-rouge">.eo</code> внутрь папки <code class="language-plaintext highlighter-rouge">EO-SOURCES/</code> внутри <code class="language-plaintext highlighter-rouge">.jar</code>-файла</p></li> <li><p><strong>Развернуть</strong>: упаковать артефакт <code class="language-plaintext highlighter-rouge">.jar</code> и поместить его в Maven Central.</p></li> <li><p><strong>Push</strong>: отправьте запрос на объединение в репозиторий <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a></p></li> <li><p><strong>Слияние</strong>: мы тестируем и объединяем запрос на включение изменений</p></li></ul><p>Это итеративный процесс, который повторяется снова и снова, пока не будут обработаны все необходимые объекты <code class="language-plaintext highlighter-rouge">.eo</code>, и их атомы будут представлены в виде файлов <code class="language-plaintext highlighter-rouge">.class</code>. Затем все файлы <code class="language-plaintext highlighter-rouge">.xmir</code> транспилируются в файлы <code class="language-plaintext highlighter-rouge">.java</code>, а затем компилируются в двоичные файлы <code class="language-plaintext highlighter-rouge">.class</code>. Затем они проходят тестирование, упаковываются и развертываются в Maven Central. Затем они объединяются с веткой <code class="language-plaintext highlighter-rouge">master</code> в <a href="https://www.objectionary.com">Objectionary</a> через запрос на объединение.</p><p>Первая часть алгоритма может быть автоматизирована с помощью <a href="https://github.com/cqfn/eo">нашего плагина Maven</a>, просто поместив исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code> в <code class="language-plaintext highlighter-rouge">src/main/eo/</code> и добавив это в <code class="language-plaintext highlighter-rouge">pom.xml</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;project&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.eolang&lt;/groupId&gt;
        &lt;artifactId&gt;eo-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;register&lt;/goal&gt;
              &lt;goal&gt;assemble&lt;/goal&gt;
              &lt;goal&gt;transpile&lt;/goal&gt;
              &lt;goal&gt;copy&lt;/goal&gt;
              &lt;goal&gt;unplace&lt;/goal&gt;
              &lt;goal&gt;unspile&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    [...]
  &lt;/build&gt;
  [...]
&lt;/project&gt;
</code></pre></div></div><p>Цель “register” будет сканировать каталог <code class="language-plaintext highlighter-rouge">src/main/eo/</code>, находить все исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code> и “регистрировать” их в специальном CSV-каталоге <code class="language-plaintext highlighter-rouge">target/eo-foreigns.csv</code>. Затем цель “assemble” вызовет следующие цели: <code class="language-plaintext highlighter-rouge">parse</code>, <code class="language-plaintext highlighter-rouge">optimize</code>, <code class="language-plaintext highlighter-rouge">discover</code>, <code class="language-plaintext highlighter-rouge">pull</code> и <code class="language-plaintext highlighter-rouge">resolve</code>. Все эти цели используют CSV-каталог при разборе, оптимизации, извлечении и так далее.</p><p>Когда все они выполнены, <code class="language-plaintext highlighter-rouge">assemble</code> проверяет каталог: требуется ли парсинг еще каких-либо файлов <code class="language-plaintext highlighter-rouge">.eo</code>? Если требуется, запускается еще один цикл с парсингом. Когда все файлы <code class="language-plaintext highlighter-rouge">.eo</code> разобраны, выполняется цель <code class="language-plaintext highlighter-rouge">transpile</code>, которая преобразует файлы <code class="language-plaintext highlighter-rouge">.xmir</code> в <code class="language-plaintext highlighter-rouge">.java</code> и помещает их в <code class="language-plaintext highlighter-rouge">target/generated-sources</code>. Остальное выполняется стандартным плагином <a href="https://maven.apache.org/plugins/maven-compiler-plugin/"><code class="language-plaintext highlighter-rouge">maven-compiler-plugin</code></a>.</p><p>Давайте обсудим каждый шаг подробно.</p><h2 id="parse-">Parse 🌵</h2><p>Предположим, что это исходный код на языке <code class="language-plaintext highlighter-rouge">.eo</code> в файле <code class="language-plaintext highlighter-rouge">src/main/eo/hello.eo</code>:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+alias org.eolang.io.stdout

[] &gt; hello "Jeff" &gt; user stdout &gt; @ "Hello, %s!" user ```

Он будет разобран в данное XMIR (XML Intermediate Representation):

</code></pre></div></div><program> <o name="hello" line="1"> <o name="user" data="string" line="2">Jeff</o> <o name="@" base="stdout" line="3"> <o data="string" line="4">Hello, %s!</o> <o base="user" line="5" /> </o> </o> </program><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Если вам интересно, что означает этот XML, прочитайте [этот документ](https://arxiv.org/abs/2111.13384): в нем есть раздел о XMIR.

## Optimize 🌵

На этом этапе XMIR, созданный парсером, проходит через несколько XSL-преобразований, иногда получая дополнительные элементы и атрибуты. Наш пример XMIR может получить новый атрибут `@ref`, указывающий ссылку на объект `user` на строке, где объект был определен.

</code></pre></div></div><program> <o name="hello" line="1"> <o name="user" data="string" line="2">Jeff</o> <o name="@" base="stdout" line="3"> <o data="string" line="4">Hello, %s!</o> <o base="user" line="5" ref="2" /> </o> </o> </program><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Некоторые преобразования XSL могут проверять грамматические или семантические ошибки и добавлять новый элемент `&lt;errors/&gt;`, если что-то неправильно обнаружено. Таким образом, если разбор не обнаружил синтаксических ошибок, все остальные ошибки будут видны внутри документа XMIR, например, вот так:

</code></pre></div></div><program> <errors> &lt;error line=&gt;The program has no package&lt;/error&gt; </errors> <o name="hello" line="1"> <o name="user" data="string" line="2">Jeff</o> <o name="@" base="stdout" line="3"> <o data="string" line="4">Hello, %s!</o> <o base="user" line="5" ref="2" /> </o> </o> </program><p>```</p><p>Кстати, это не настоящая ошибка, я просто придумал ее.</p><h2 id="discover-">Discover 🌵</h2><p>На этом шаге мы определяем, какие объекты являются “иностранными”. В нашем примере объект <code class="language-plaintext highlighter-rouge">user</code> не является иностранным, так как он определен в коде, который у нас перед глазами, в то время как объект <code class="language-plaintext highlighter-rouge">stdout</code> не определен здесь и поэтому является иностранным.</p><p>Проходя через все файлы <code class="language-plaintext highlighter-rouge">.xmir</code>, мы можем легко определить, какой объект является иностранным, просто взглянув на их имена. Как только мы видим ссылку на <code class="language-plaintext highlighter-rouge">org.eolang.io.stdout</code>, мы проверяем наличие файла <code class="language-plaintext highlighter-rouge">org/eolang/io/stdout.eo</code> в каталоге со всеми исходными файлами <code class="language-plaintext highlighter-rouge">.eo</code>. Если файл отсутствует, мы помещаем имя объекта в каталог CSV и считаем его иностранным.</p><h2 id="pull">Pull</h2><p>Здесь мы просто пытаемся найти исходные коды файлов <code class="language-plaintext highlighter-rouge">.eo</code> для всех внешних объектов в Objectionary, просматривая его <a href="https://github.com/yegor256/objectionary">репозиторий на GitHub</a>. Например, вот где мы найдем <a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a>. Мы находим их там и загружаем на локальный диск.</p><p>Обратите внимание, мы извлекаем исходные коды. Не бинарные файлы или скомпилированные документы XMIR, а исходники в формате <code class="language-plaintext highlighter-rouge">.eo</code>.</p><h2 id="resolve-">Resolve 🌵</h2><p>Вот как может выглядеть <code class="language-plaintext highlighter-rouge">stdout.eo</code> после выполнения команды pull: <a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a></p><p>```xml +package org.eolang.io +rt jvm org.eolang:eo-runtime:0.10.2</p><p>[text] &gt; stdout /bool ```</p><p>Объект представляет собой <em>атом</em>. Это означает, что даже если у нас есть его исходный код, он не полон без части платформозависимого двоичного кода. Атом является объектом, реализованным платформой выполнения, на которой выполняется программа EO (также известная как <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">механизм FFI</a>). Строка, начинающаяся с <code class="language-plaintext highlighter-rouge">+rt</code> (runtime), объясняет, где можно получить код времени выполнения. Часть <code class="language-plaintext highlighter-rouge">jvm</code> является названием времени выполнения.</p><p>Мы переходим на <a href="https://search.maven.org/">Maven Central</a>, находим там артефакт <a href="https://search.maven.org/artifact/org.eolang/eo-runtime"><code class="language-plaintext highlighter-rouge">org.eolang:eo-runtime:0.10.2</code></a> и распаковываем его (в конце концов, это zip-архив с файлами <code class="language-plaintext highlighter-rouge">.class</code>).</p><p>Кстати, программа может содержать несколько мета-инструкций <code class="language-plaintext highlighter-rouge">+rt</code>, например:</p><p>```text +package org.eolang.io +rt jvm org.eolang:eo-runtime:0.10.2 +rt ruby eo-core:0.5.8 +rt python eo-basics:0.0.3</p><p>[text] &gt; stdout /bool ```</p><p>Здесь три платформы времени выполнения будут знать, где найти отсутствующий код для атома <code class="language-plaintext highlighter-rouge">stdout</code>: EO➝Java обратится к <a href="https://search.maven.org/">Maven Central</a> для получения JAR-артефакта, EO➝Ruby обратится к <a href="https://rubygems.org/">RubyGems</a>, пытаясь найти гем с именем <code class="language-plaintext highlighter-rouge">eo-core</code> и версией <code class="language-plaintext highlighter-rouge">0.5.8</code>, в то время как EO➝Python обратится к <a href="https://pypi.org/">PyPi</a>, пытаясь найти пакет <code class="language-plaintext highlighter-rouge">eo-basics</code> с версией <code class="language-plaintext highlighter-rouge">0.0.3</code>.</p><h2 id="place-">Place 🌵</h2><p>Затем мы помещаем все файлы с расширением <code class="language-plaintext highlighter-rouge">.class</code>, найденные в распакованном JAR-архиве, в каталог <code class="language-plaintext highlighter-rouge">target/classes</code>. Мы делаем это, чтобы помочь плагину Maven Compiler Plugin найти их в classpath.</p><h2 id="mark-">Mark 🌵</h2><p>В каждом приходящем JAR-файле мы можем найти исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code>. Они представляют программы, которые были в класспасе этого JAR-файла во время его построения. Мы также рассматриваем их как внешние объекты и добавляем их в CSV-каталог.</p><h2 id="transpile-">Transpile 🌵</h2><p>Когда все внешние объекты, зарегистрированные в каталоге, загружены, скомпилированы и оптимизированы, мы готовы начать <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler"><em>транспиляцию</em></a>. Вместо того чтобы компилировать XMIR напрямую в байт-код, мы транспилируем его в <code class="language-plaintext highlighter-rouge">.java</code> и позволяем Java-компилятору выполнить работу по генерации байт-кода.</p><p>Мы считаем, что есть несколько преимуществ транспиляции в Java по сравнению с компиляцией в байткод:</p><ul> <li><p>Вывод кода легче читать и отлаживать.</p></li> <li><p>“Оптимизационные возможности существующих компиляторов переиспользуются.”</p></li> <li><p>Сложность транспиляции ниже, чем у компилятора.</p></li> <li><p>Переносимость выходного кода выше.</p></li></ul><p>У нас уже есть два транспайлера EO➝Java: <a href="https://github.com/cqfn/eo">канонический</a> и <a href="https://github.com/polystat/hse-transpiler">тот</a>, который сделала <a href="https://www.hse.ru/en/">Университет НИУ ВШЭ</a>. У нас также есть экспериментальный транспайлер EO➝Python <a href="https://github.com/polystat/eo2py">transpiler</a>, созданный студентами <a href="https://innopolis.university/en/">Университета Иннополис</a>. Скорее всего, когда вы будете читать эту статью, появятся еще больше транспайлеров.</p><p>Хотя мы верим в транспиляцию, всё равно возможно создание компиляторов EO➝Bytecode, EO➝LLVM или EO➝x86. Пожалуйста, не стесняйтесь попробовать!</p><h2 id="compile">Compile</h2><p>На этом этапе стандартный <a href="https://maven.apache.org/plugins/maven-compiler-plugin/">Maven Compiler Plugin</a> находит автоматически созданные файлы <code class="language-plaintext highlighter-rouge">.java</code> в <code class="language-plaintext highlighter-rouge">target/generated-sources</code> и преобразует их в файлы <code class="language-plaintext highlighter-rouge">.class</code>.</p><h2 id="unplace-">Unplace 🌵</h2><p>Здесь мы удаляем все файлы <code class="language-plaintext highlighter-rouge">.class</code>, распакованные из зависимостей. Это необходимо, чтобы избежать их упаковки в конечный JAR-файл.</p><p>Мы выполняем размещение и потом удаление просто потому, что плагин Maven Compiler <a href="https://stackoverflow.com/questions/3410548">не позволяет</a> нам расширять classpath во время выполнения. Если бы это было возможно, мы просто загрузили бы зависимости из Maven Central и добавили их в classpath, без распаковки, размещения и потом удаления.</p><h2 id="unspile-">Unspile 🌵</h2><p>Здесь мы удаляем все файлы <code class="language-plaintext highlighter-rouge">.class</code> из директории <code class="language-plaintext highlighter-rouge">target/classes/</code>, которые были автоматически созданы из <code class="language-plaintext highlighter-rouge">.eo</code>. Мы не хотим отправлять бинарные файлы, которые могут быть созданы из исходных файлов <code class="language-plaintext highlighter-rouge">.eo</code>. Мы хотим отправить только атомы, которые являются исходными файлами <code class="language-plaintext highlighter-rouge">.java</code>.</p><h2 id="copy-">Copy 🌵</h2><p>На этом шаге мы берем все исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code> из директории <code class="language-plaintext highlighter-rouge">src/main/eo/</code> и копируем их в директорию <code class="language-plaintext highlighter-rouge">target/classes/EO-SOURCES/</code>. Позже они будут упакованы вместе с файлами <code class="language-plaintext highlighter-rouge">.class</code> в <code class="language-plaintext highlighter-rouge">.jar</code>, который будет развернут в Maven Central. При копировании мы заменяем <code class="language-plaintext highlighter-rouge">0.0.0</code> в версии выполнения на версию, которая разворачивается в данный момент. Взгляните на файл <a href="https://github.com/cqfn/eo/blob/master/eo-runtime/src/main/eo/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a>, в его репозитории исходного кода.</p><p>```text +package org.eolang.io +rt jvm org.eolang:eo-runtime:0.0.0</p><p>[text] &gt; stdout /bool ```</p><p>Версия на строке <code class="language-plaintext highlighter-rouge">+rt</code> - <code class="language-plaintext highlighter-rouge">0.0.0</code>. При копировании исходных файлов в JAR, этот текст заменяется.</p><p>Мотивация для доставки исходных файлов вместе с бинарными файлами заключается в следующем. Когда бинарные файлы атомов компилируются из Java в байт-код, они остаются рядом с транспилированными исходными файлами. Они компилируются вместе. Кроме того, модульные тесты также зависят как от исходных файлов атомов, так и от автоматически генерируемых/транспилированных исходных файлов. Мы хотим, чтобы будущие пользователи JAR-файла знали, какие исходные файлы у нас были на месте во время компиляции, возможно, чтобы они могли воспроизвести это или по крайней мере знать, что окружало бинарные файлы, которые они получают.</p><p>С практической точки зрения, нам необходимы эти источники в JAR, чтобы позволить шагу <strong>Mark</strong> понять, какие объекты стоит вытягивать рядом с разрешенными атомами.</p><h2 id="deploy">Deploy</h2><p>Здесь мы упаковываем все из <code class="language-plaintext highlighter-rouge">target/classes/</code> в JAR-архив и размещаем его в Maven Central.</p><p>Я предлагаю также размещать исходные коды на страницах GitHub, чтобы пользователи могли видеть их в Интернете. Кроме того, это будет полезно позже, когда мы создадим запрос на добавление в словарь Objectionary. Проверьте этот скрипт <a href="https://github.com/yegor256/eo-files/blob/master/.rultor.yml#L17-L31"><code class="language-plaintext highlighter-rouge">.rultor.yml</code></a> в одной из моих библиотек на Esperanto, он размещает исходные коды <code class="language-plaintext highlighter-rouge">.eo</code> на страницах GitHub, правильно заменяя маркеры версии <code class="language-plaintext highlighter-rouge">0.0.0</code> в них.</p><h2 id="push">Push</h2><p>Когда развертывание завершено и серверы CDN Maven Central обновляются, пришло время отправить pull request в <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a>. Исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code> объектов помещаются в <code class="language-plaintext highlighter-rouge">objects/</code>, а их модульные тесты - в <code class="language-plaintext highlighter-rouge">tests/</code>. В основном, мы просто копируем <code class="language-plaintext highlighter-rouge">src/main/eo/</code> и <code class="language-plaintext highlighter-rouge">src/test/eo</code> туда. Но, стоп… важная деталь. В исходных файлах, как было сказано ранее, у нас есть версии <code class="language-plaintext highlighter-rouge">+rt</code>, установленные на <code class="language-plaintext highlighter-rouge">0.0.0</code>. Здесь, когда мы копируем в Objectionary, версии должны быть установлены на реальные числа.</p><h2 id="merge">Merge</h2><p>Когда появляется запрос на перенос, предварительно настроенное действие GitHub в репозитории <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a> конвертирует все исходные файлы <code class="language-plaintext highlighter-rouge">.eo</code> на все известные платформы и запускает все модульные тесты. Если все чисто, мы рассматриваем запрос на перенос и решаем, соответствуют ли предлагаемые объекты уже существующим в Объективарии.</p><p>После объединения запроса на слияние эти объекты становятся частью централизованного словаря всех объектов EO. Взгляните на <a href="https://github.com/yegor256/objectionary/pull/2">этот запрос на слияние</a>, где новый объект был представлен в Objectionary после того, как его атом был развернут в Maven Central.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/33 on 2023-08-30 at 09:29</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?15ff2847650"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
