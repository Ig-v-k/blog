<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Sometimes you might be tempted to use a two-stage construction for your object. However, I suggest reevaluating your design principles if you feel such an inclination." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Is Two-Step Initialization a Solution or a Symptom?"/> <meta name="twitter:description" property="og:description" content="Sometimes you might be tempted to use a two-stage construction for your object. However, I suggest reevaluating your design principles if you feel such an inclination."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2023/08/08/two-step-initialization.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d7375766803"/> <link rel="apple-touch-icon" href="/favicon.ico?d7375766803"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d7375766803"/> <link rel="stylesheet" href="/css/icons.css?d7375766803"/> <link rel="canonical" href="https://www.yegor256.com/ru/2023/08/08/two-step-initialization.html" /> <title>Is Two-Step Initialization a Solution or a Symptom?</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Is Two-Step Initialization a Solution or a Symptom?</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2023/08/08/two-step-initialization.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Иногда может показаться практичным выполнить дополнительные инициализационные шаги для объекта после завершения его конструктора. Однако я считаю, что такие требования указывают на скрытые проблемы проектирования, такие как изменяемость объекта, хрупкость базового класса, нарушение слоистости и несосредоточенную абстракцию. Конструктор должен быть достаточно хорошим для всех сценариев. Если это не так, следует провести рефакторинг объекта.</p><p>Вот как обычно происходит (я нашел это в <a href="https://github.com/apache/kafka/blob/e0b7499103df9222140cdbf7047494d92913987e/clients/src/main/java/org/apache/kafka/common/security/oauthbearer/internals/secured/RefreshingHttpsJwks.java">Apache Kafka</a>):</p><p>Ожидается, что объект будет использоваться следующим образом:</p><p>Могут быть практические обоснования для этой <em>двухэтапной конструкции</em>, которая, <a href="https://learn.microsoft.com/en-us/cpp/mfc/one-stage-and-two-stage-construction-of-objects?view=msvc-170">по словам Microsoft</a>, считается “всегда более безопасным” подходом к созданию объекта. Однако я убежден, что каждая из этих причин указывает на недостаточно хорошо продуманный дизайн и должна служить катализатором для рефакторинга.</p><p>Рассмотрим класс Java <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html">auto-closeable</a>, который открывает поток в своем конструкторе и ожидает его закрытия в методе <code class="language-plaintext highlighter-rouge">close()</code> в разумных пределах.</p><p>Однако, если исключение времени выполнения возникает в конструкторе, поток не будет закрыт и ресурс <a href="https://stackoverflow.com/a/29243066/187141">будет утекать</a>:</p><p>Метод <code class="language-plaintext highlighter-rouge">close()</code> не будет вызван оператором <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a>, так как объект не будет полностью создан, и его инициализация не будет завершена. Однако, даже если инициализация не завершена, экземпляр <code class="language-plaintext highlighter-rouge">FileInputStream</code> выполнит часть своей работы: он откроет файл. Однако, он никогда его не закроет.</p><p>Двухэтапная инициализация может быть решением:</p><p>Теперь код можно использовать следующим образом, что, действительно, безопаснее, поскольку поток всегда будет закрыт:</p><p>Несмотря на то, что это может быть хорошим обходным путем, это только маскировка недостатка в дизайне: изменяемость атрибута. Более лучшим решением было бы избавиться от изменяемости <code class="language-plaintext highlighter-rouge">Book</code> и удалить метод <code class="language-plaintext highlighter-rouge">init()</code>.</p><p>Таким образом, <a href="https://en.wikipedia.org/wiki/Initialization_%28programming%29">инициализация</a> потока должна производиться вне объекта <code class="language-plaintext highlighter-rouge">Book</code>, а затем передаваться ему в качестве аргумента конструктора (обратите внимание на модификатор <code class="language-plaintext highlighter-rouge">final</code> поля <code class="language-plaintext highlighter-rouge">in</code>).</p><p>Затем, вот как мы можем использовать это:</p><p>Теперь, как поток, так и книга определенно будут закрыты.</p><p>Основная причина проблемы здесь связана с изменяемостью атрибута <code class="language-plaintext highlighter-rouge">in</code>, что создает потенциал для утечки ресурсов. Если мы заранее договоримся о том, что каждый объект должен быть неизменяемым, эта проблема не возникнет в первую очередь. Нам не понадобится обходное решение, такое как инициализация в два шага, потому что мы не столкнемся с классом, в котором атрибут может остаться неинициализированным. Кажется, что этот пример служит еще одним подтверждением преимуществ неизменности объектов.</p><p>Рассмотрим этот родительский класс с неизменяемым атрибутом <code class="language-plaintext highlighter-rouge">title</code>:</p><p>Теперь давайте расширим его (снова, атрибут <code class="language-plaintext highlighter-rouge">author</code> неизменяемый):</p><p>Что, по вашему мнению, будет напечатано после выполнения следующих действий?</p><p>This is what:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Title: Object Thinking
Author: null
</code></pre></div></div><p>Почему поле <code class="language-plaintext highlighter-rouge">author</code> выводится как <code class="language-plaintext highlighter-rouge">null</code>, когда мы передали строку <code class="language-plaintext highlighter-rouge">"David West"</code> в конструкторе? Причина в том, что вызван конструктор родительского класса <code class="language-plaintext highlighter-rouge">super()</code> до инициализации <code class="language-plaintext highlighter-rouge">this.author</code>. Конструктор класса <code class="language-plaintext highlighter-rouge">Product</code> вызвал свой собственный <a href="https://en.wikipedia.org/wiki/Virtual_function">виртуальный</a> метод <code class="language-plaintext highlighter-rouge">print()</code>, который был переопределен в производном классе <code class="language-plaintext highlighter-rouge">Book</code>. Эта проблема может быть более общим случаем “<a href="https://en.wikipedia.org/wiki/Fragile_base_class">хрупкого базового класса</a>”: базовый класс вызывает свой собственный метод, ожидая его работы по определению, но этот метод неожиданно заменяется другой реализацией в производном классе, что приводит к непреднамеренному и неправильному поведению. Возможность замены метода является тем, что делает базовый класс хрупким.</p><p>Использование двухэтапного создания может решить эту проблему, сохраняя инициализацию атрибутов в конструкторе, а “печатающую” функциональность перемещая в новый метод <code class="language-plaintext highlighter-rouge">init()</code>. Однако такой подход только скрывает основной дизайнерский недостаток: врожденную хрупкость класса.</p><p>Более всестороннее решение двоякое. Во-первых, поддерживайте конструкторы без кода, как ранее предлагалось. Во-вторых, предпочитайте <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">композицию перед наследованием</a>, как также ранее рекомендовалось. Вот как:</p><p>Теперь оба класса помечены как <code class="language-plaintext highlighter-rouge">final</code>, что делает технически невозможным переопределение любых из их методов. Вместо расширения <code class="language-plaintext highlighter-rouge">Product</code>, класс <code class="language-plaintext highlighter-rouge">Book</code> инкапсулирует его экземпляр. Метод <code class="language-plaintext highlighter-rouge">print()</code> в классе <code class="language-plaintext highlighter-rouge">Book</code> контролирует функциональность печати, передавая часть этой ответственности методу <code class="language-plaintext highlighter-rouge">product.print()</code>. Такой дизайн становится единственным приемлемым вариантом, если мы согласны с самого начала, что все конструкторы должны оставаться без кода и что наследование реализации запрещено.</p><p>Если вы достаточно долго писали код на Java, вам, безусловно, будет знаком этот подход к проектированию.</p><p>Здесь конструктор присваивает значения по умолчанию четырем атрибутам объекта, тогда как метод <code class="language-plaintext highlighter-rouge">init()</code> впоследствии обновляет их на основе значений из DTO “конфигурации”. Этот метод инициализации объекта может показаться более привлекательным, чем серия вызовов сеттеров, поскольку он гарантирует одновременное присвоение всех необходимых атрибутов без упущений. Такая гарантия не обеспечивается при использовании изолированных сеттеров. Кроме того, DTO может быть автоматически заполнен из XML- или JSON-файла, что при передаче в метод <code class="language-plaintext highlighter-rouge">init()</code> дополнительно упрощает код.</p><p>Однако это всего лишь маскирует основной дизайн-дефект: класс слишком объемный. Вопрос не в количестве строк кода, а в множестве внешних элементов, которые он пытается абстрагировать: интернет-адрес, TCP-порт, строка входа, пароль и, скорее всего, еще больше в будущем. В настоящее время <code class="language-plaintext highlighter-rouge">Config</code> DTO удовлетворяет из-за своего скромного размера, однако кажется, что она прокладывает путь для будущего расширения, соблазняя программистов дополнять ее по своему усмотрению. С увеличением размера <code class="language-plaintext highlighter-rouge">Config</code> будет расти и количество атрибутов в <code class="language-plaintext highlighter-rouge">Database</code>. Вероятно, они вскоре перестанут совпадать. Со временем может стать сложно определить, готовит ли создание объекта <code class="language-plaintext highlighter-rouge">Database</code> его к работе или требуется предварительный вызов <code class="language-plaintext highlighter-rouge">init()</code>. Более того, будет ли достаточным просто вызов <code class="language-plaintext highlighter-rouge">init()</code> для полного использования объекта?</p><p>Если бы мы изначально согласились, что наши объекты не должны инкапсулировать более трех атрибутов, как предлагалось ранее, мы бы провели рефакторинг этого класса. Метод <code class="language-plaintext highlighter-rouge">init()</code> был бы убран, а все необходимые параметры передавались бы через его первичные или вторичные конструкторы. Также полезно было бы сохранить все атрибуты неизменяемыми.</p><p>Кажется, что даже паттерн проектирования <a href="https://en.wikipedia.org/wiki/Builder_pattern">Строитель</a> был бы лучшим решением, чем метод <code class="language-plaintext highlighter-rouge">init()</code> в этом конкретном случае.</p><p>Рассмотрим следующие два класса Java, которые зависят друг от друга:</p><p>Очевидно, что невозможно создать экземпляр <code class="language-plaintext highlighter-rouge">Book</code> или <code class="language-plaintext highlighter-rouge">Order</code>, так как каждый из них требует предварительного создания другого. Двухфазовое конструирование в сочетании с изменяемыми атрибутами и сеттерами может выглядеть как решение.</p><p>Теперь их можно создать экземпляр:</p><p>Однако этот дизайн обнаруживает существенный недостаток: оба объекта <code class="language-plaintext highlighter-rouge">order</code> и <code class="language-plaintext highlighter-rouge">book</code> остаются в неполном состоянии, пока не вызываются соответствующие методы <code class="language-plaintext highlighter-rouge">init()</code>. Когда код принимает форму, его первоначальный автор понимает правильную последовательность вызовов методов: сначала конструктор, за ним сеттер, и только после этого метод <code class="language-plaintext highlighter-rouge">init()</code>. Однако в будущем, по мере изменения кода другими людьми, это временное связывание между вызовами методов может быть легко упущено. Непреднамеренный вызов <code class="language-plaintext highlighter-rouge">init()</code> перед сеттером может привести к ошибкам времени выполнения, которые трудно диагностировать.</p><p>Основная проблема здесь заключается в нарушении принципа слоистости, присутствующего в дизайне как <code class="language-plaintext highlighter-rouge">Book</code>, так и <code class="language-plaintext highlighter-rouge">Order</code>: они взаимозависимы. Если я правильно помню, Мартин Фаулер утверждает, что “слой может обращаться только к слоям, находящимся под ним”. В контексте нашего дизайна книги и заказа нет четкого различия между этими слоями: невозможно определить, какой слой является базовым для другого. Трудности с инстанцированием являются только проявлением этой проблемы, и двухэтапная инициализация служит скорее временной мерой, чем фактическим решением.</p><p>Я не знаю, как улучшить этот код напрямую. Вероятно, необходимо тщательно переосмыслить всю архитектуру, введя более подходящие абстракции вместо <code class="language-plaintext highlighter-rouge">Book</code> и <code class="language-plaintext highlighter-rouge">Order</code>.</p><p>Похоже, что двухэтапная инициализация на самом деле не решает проблемы, а лишь временно их скрывает. Хотя вы можете использовать методы <code class="language-plaintext highlighter-rouge">init()</code> в своих объектах, они выглядят как флаги с надписью “Я не смог правильно спроектировать этот класс!”.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/36 on 2023-11-17 at 12:35</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d7375766803"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
