<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Java Web App Architecture In Takes Framework"/> <meta name="twitter:description" property="og:description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2015/03/22/takes-java-web-framework.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?790d6e310ac"/> <link rel="apple-touch-icon" href="/favicon.ico?790d6e310ac"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?790d6e310ac"/> <link rel="stylesheet" href="/css/icons.css?790d6e310ac"/> <link rel="canonical" href="https://www.yegor256.com/ru/2015/03/22/takes-java-web-framework.html" /> <title>Java Web App Architecture In Takes Framework</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Java Web App Architecture In Takes Framework</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2015/03/22/takes-java-web-framework.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Я раньше использовал Servlets, JSP, JAX-RS, Spring Framework, Play Framework, JSF с Facelets и немного Spark Framework. Все эти решения, по моему скромному мнению, очень далеки от объектно-ориентированного и элегантного подхода. Все они полны статических методов, не тестируемых структур данных и грязных хаков. Поэтому примерно месяц назад я решил создать свой собственный веб-фреймворк на Java. Я положил несколько основных принципов в его основу: 1) Нет NULL-значений, 2) нет открытых статических методов, 3) нет изменяемых классов и 4) нет приведения типов классов, отражения и операторов <code class="language-plaintext highlighter-rouge">instanceof</code>. Эти четыре основных принципа должны гарантировать чистый код и прозрачную архитектуру. Именно так родился фреймворк <a href="http://www.takes.org">Takes</a>. Посмотрим, что было создано и как это работает.</p><h2 id="java-web-architecture-in-a-nutshell">Java Web Architecture in a Nutshell</h2><p>Вот как я понимаю архитектуру веб-приложения и его компоненты, простыми словами.</p><p>Сначала, чтобы создать веб-сервер, мы должны создать новый <a href="http://en.wikipedia.org/wiki/Network_socket">сетевой сокет</a>, который принимает соединения на определенном <a href="http://en.wikipedia.org/wiki/Port_%28computer_networking%29">TCP-порту</a>. Обычно это 80, но я собираюсь использовать 8080 для тестирования. В Java для этого используется класс <a href="http://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html"><code class="language-plaintext highlighter-rouge">ServerSocket</code></a>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.net.ServerSocket;
public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true);
  }
}
</code></pre></div></div><p>Этого достаточно, чтобы запустить веб-сервер. Теперь сокет готов и слушает порт 8080. Когда кто-то открывает <code class="language-plaintext highlighter-rouge">http://localhost:8080</code> в своем браузере, соединение устанавливается и браузер будет крутить свое ожидающее колесо вечно. Скомпилируйте этот фрагмент и попробуйте. Мы только что создали простой веб-сервер без использования каких-либо фреймворков. Пока мы ничего не делаем с входящими соединениями, но мы их также не отклоняем. Все они накапливаются внутри этого объекта <code class="language-plaintext highlighter-rouge">server</code>. Это происходит в фоновом потоке; поэтому нам нужно добавить этот <code class="language-plaintext highlighter-rouge">while(true)</code> после. Без этой бесконечной паузы приложение завершит свое выполнение немедленно, и сокет сервера закроется.</p><p>Следующим шагом является принятие входящих соединений. В Java это делается с помощью блокирующего вызова метода <code class="language-plaintext highlighter-rouge">accept()</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final Socket socket = server.accept();
</code></pre></div></div><p>Метод блокирует свою нить и ожидает, пока не поступит новое соединение. Как только это произойдет, возвращается экземпляр <code class="language-plaintext highlighter-rouge">Socket</code>. Чтобы принять следующее соединение, мы должны снова вызвать функцию <code class="language-plaintext highlighter-rouge">accept()</code>. Таким образом, наш веб-сервер должен работать следующим образом:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true) {
      final Socket socket = server.accept();
      // 1. Read HTTP request from the socket
      // 2. Prepare an HTTP response
      // 3. Send HTTP response to the socket
      // 4. Close the socket
    }
  }
}
</code></pre></div></div><p>Это бесконечный цикл, который принимает новое соединение, понимает его, создает ответ, возвращает ответ и снова принимает новое соединение. Протокол HTTP является безсостоятельным, что означает, что сервер не должен помнить, что произошло в предыдущем соединении. Ему важен только входящий HTTP-запрос в данном соединении.</p><p>HTTP-запрос поступает из потока ввода сокета и выглядит как многострочный блок текста. Это то, что вы увидели бы, если бы прочитали поток ввода сокета:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final BufferedReader reader = new BufferedReader(
  new InputStreamReader(socket.getInputStream())
);
while (true) {
  final String line = reader.readLine();
  if (line.isEmpty()) {
    break;
  }
  System.out.println(line);
}
</code></pre></div></div><p>Вы увидите что-то вроде этого:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: en-US,en;q=0.8,ru;q=0.6,uk;q=0.4
</code></pre></div></div><p>Клиент (например, браузер Google Chrome) передает этот текст через установленное соединение. Он подключается к порту 8080 на <code class="language-plaintext highlighter-rouge">localhost</code> и сразу же отправляет этот текст в соединение, а затем ожидает ответа.</p><p>Наша задача - создать HTTP-ответ, используя информацию, полученную в запросе. Если наш сервер очень простой, мы можем в общем-то игнорировать всю информацию в запросе и просто возвращать “Привет, мир!” для всех запросов (для простоты я использую <a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html"><code class="language-plaintext highlighter-rouge">IOUtils</code></a>).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.net.Socket;
import java.net.ServerSocket;
import org.apache.commons.io.IOUtils;
public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true) {
      try (final Socket socket = server.accept()) {
        IOUtils.copy(
          IOUtils.toInputStream("HTTP/1.1 200 OK\r\n\r\nHello, world!"),
          socket.getOutputStream()
        );
      }
    }
  }
}
</code></pre></div></div><p>Вот и всё. Сервер готов. Попробуйте скомпилировать и запустить его. Откройте свой браузер по адресу <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>, и вы увидите <code class="language-plaintext highlighter-rouge">Привет, мир!</code>.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>javac <span class="nt">-cp</span> commons-io.jar Foo.java
<span class="nv">$ </span>java <span class="nt">-cp</span> commons-io.jar:. Foo &amp;
<span class="nv">$ </span>curl http://localhost:8080 <span class="nt">-v</span>

<span class="k">*</span> Rebuilt URL to: http://localhost:8080/

<span class="k">*</span> Connected to localhost <span class="o">(</span>::1<span class="o">)</span> port 8080 <span class="o">(</span><span class="c">#0)</span>

GET / HTTP/1.1 User-Agent: curl/7.37.1 Host: localhost:8080 Accept: <span class="k">*</span>/<span class="k">*</span>

&lt; HTTP/1.1 200 OK

<span class="k">*</span> no chunk, no close, no size. Assume close to signal end &lt;

<span class="k">*</span> Closing connection 0 Hello, world! <span class="sb">```</span>

Вот и все, что вам нужно для создания веб-сервера. Теперь давайте обсудим, как сделать его объектно-ориентированным и комбинируемым. Давайте попробуем посмотреть, как был создан фреймворк <span class="o">[</span>Takes]<span class="o">(</span>http://www.takes.org<span class="o">)</span><span class="nb">.</span>

<span class="c">## Routing/Dispatching</span>

Маршрутизация/диспетчеризация объединены с печатью ответа в Takes. Вам нужно только создать один класс, который реализует интерфейс <span class="o">[</span><span class="sb">`</span>Take<span class="sb">`</span><span class="o">](</span>http://static.javadoc.io/org.takes/takes/1.1/org/takes/Take.html<span class="o">)</span>, чтобы создать работающее веб-приложение.

</code></pre></div></div><p>import org.takes.Request; import org.takes.Take; public final class TkFoo implements Take { @Override public Response route(final Request request) { return new RsText(“Hello, world!”); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
И теперь пришло время запустить сервер:

</code></pre></div></div><p>import org.takes.http.Exit; import org.takes.http.FtBasic; public class Foo { public static void main(final String… args) throws Exception { new FtBasic(new TkFoo(), 8080).start(Exit.NEVER); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Этот класс `FtBasic` выполняет те же самые операции с сокетами, что и описано выше. Он запускает серверный сокет на порту 8080 и направляет все входящие подключения через экземпляр `TkFoo`, который мы передаем в его конструктор. Он выполняет это направление в бесконечном цикле, проверяя каждую секунду, не пора ли остановиться с помощью экземпляра `Exit`. Очевидно, `Exit.NEVER` всегда отвечает: "Пожалуйста, не останавливайся".

## HTTP Request

Теперь давайте посмотрим, что находится в HTTP-запросе, приходящем в `TkFoo`, и что мы можем извлечь из него. Вот как интерфейс [`Request`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html) определен в [Takes](http://www.takes.org):

</code></pre></div></div><p>public interface Request { Iterable<String> head() throws IOException; InputStream body() throws IOException; }</String></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Запрос разделен на две части: заголовок и тело. Заголовок содержит все строки перед пустой строкой, которая начинает тело, в соответствии с HTTP-спецификацией [RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html). В фреймворке существует множество полезных декораторов для `Request`. Например, `RqMethod` поможет вам получить имя метода из первой строки заголовка.

</code></pre></div></div><p>final String method = new RqMethod(request).method();</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`RqHref` will help extract the query part and parse it. For example, this is the request:

</code></pre></div></div><p>GET /user?id=123 HTTP/1.1 Host: www.example.com</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Этот код извлечет `123`:

</code></pre></div></div><p>final int id = Integer.parseInt( new RqHref(request).href().param(“id”).get(0) );</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`RqPrint` can get the entire request or its body printed as a `String`:

</code></pre></div></div><p>final String body = new RqPrint(request).printBody();</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Идея здесь состоит в том, чтобы сохранить интерфейс `Request` простым и предоставить эту функциональность разбора запроса его декораторам. Такой подход помогает фреймворку сохранять классы маленькими и сплоченными. Каждый декоратор очень маленький и надежный, делая ровно одну вещь. Все эти декораторы находятся в пакете [`org.takes.rq`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/package-summary.html). Как вы уже, возможно, понимаете, префикс `Rq` означает `Request`.

## First Real Web App

Давайте создадим наше первое реальное веб-приложение, которое будет выполнять полезные действия. Я бы рекомендовал начать с класса `Entry`, который требуется в Java для запуска приложения из командной строки.

</code></pre></div></div><p>import org.takes.http.Exit; import org.takes.http.FtCli; public final class Entry { public static void main(final String… args) throws Exception { new FtCli(new TkApp(), args).start(Exit.NEVER); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Этот класс содержит только один статический метод `main()`, который будет вызываться JVM при запуске приложения из командной строки. Как видите, он создает экземпляр [`FtCli`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtCli.html), передавая ему экземпляр класса `TkApp` и аргументы командной строки. Мы создадим класс `TkApp` сейчас. `FtCli` (переводится как "интерфейс командной строки фронтенда") создает экземпляр того же `FtBasic`, обертывает его несколькими полезными декораторами и настраивает его в соответствии с аргументами командной строки. Например, `--port=8080` будет преобразован в номер порта `8080` и передан вторым аргументом конструктора `FtBasic`.

Само веб-приложение называется `TkApp` и расширяет `TsWrap`.

</code></pre></div></div><p>import org.takes.Take; import org.takes.facets.fork.FkRegex; import org.takes.facets.fork.TkFork; import org.takes.tk.TkWrap; import org.takes.tk.TkClasspath; final class TkApp extends TkWrap { TkApp() { super(TkApp.make()); } private static Take make() { return new TkFork( new FkRegex(“/robots.txt”, “”), new FkRegex(“/css/.*”, new TkClasspath()), new FkRegex(“/”, new TkIndex()) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Мы обсудим этот класс `TkFork` через минуту.

Если вы используете Maven, это `pom.xml`, с которого следует начать:

</code></pre></div></div><p>&lt;?xml version=”1.0”?&gt;</p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>foo</groupId> <artifactId>foo</artifactId> <version>1.0-SNAPSHOT</version> <dependencies> <dependency> <groupId>org.takes</groupId> <artifactId>takes</artifactId> <version>0.9</version> </dependency> </dependencies> <build> <finalName>foo</finalName><plugins><plugin> <artifactId>maven-dependency-plugin</artifactId> <executions> <execution> <goals> <goal>copy-dependencies</goal> </goals> <configuration> <outputDirectory>${project.build.directory}/deps</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Запуск команды `mvn clean package` должен создать файл `foo.jar` в папке `target` и собрать все зависимости JAR в папке `target/deps`. Теперь вы можете запустить приложение из командной строки.

</code></pre></div></div><p>$ mvn clean package $ java -Dfile.encoding=UTF-8 <br /> -cp ./target/foo.jar:./target/deps/* foo.Entry –port=8080</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Приложение готово, и вы можете развернуть его, скажем, на Heroku. Просто создайте файл `Procfile` в корне репозитория и отправьте репозиторий на Heroku. Вот как должен выглядеть файл `Procfile`:

</code></pre></div></div><p>web: java -Dfile.encoding=UTF-8 <br /> -cp target/foo.jar:target/deps/* <br /> foo.Entry –port=${PORT}</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## `TkFork`

Класс `TkFork` кажется одним из основных элементов фреймворка. Он помогает маршрутизировать входящий HTTP-запрос к правильному *take*. Его логика очень проста, и внутри него всего несколько строк кода. Он инкапсулирует коллекцию "forks", которые являются экземплярами интерфейса `Fork`.

</code></pre></div></div><p>public interface Fork { Iterator<Response> route(Request req) throws IOException; }</Response></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Его единственный метод `route()` либо возвращает пустой итератор, либо итератор с одним `Response`. `TkFork` проходит через все вилки, вызывая их методы `route()` до тех пор, пока один из них не вернет ответ. Когда это происходит, `TkFork` возвращает этот ответ вызывающей стороне, которая является [`FtBasic`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html).

Давайте сейчас создадим простую ветку сами. Например, мы хотим показать состояние приложения при запросе `/status` URL. Вот код:

</code></pre></div></div><p>final class TkApp extends TkWrap { private static Take make() { return new TkFork( new Fork() { @Override public Iterator<Response> route(Request req) { final Collection<Response> responses = new ArrayList&lt;&gt;(1); if (new RqHref(req).href().path().equals("/status")) { responses.add(new TkStatus()); } return responses.iterator(); } } ); } }</Response></Response></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Я считаю, что логика здесь ясна. Мы либо возвращаем пустой итератор, либо итератор с экземпляром `TkStatus` внутри. Если возвращается пустой итератор, `TkFork` попытается найти другую вилку в коллекции, которая фактически получает экземпляр `Response`. Кстати, если ничего не найдено и все вилки возвращают пустые итераторы, `TkFork` вызовет исключение "Страница не найдена".

Эта конкретная логика реализована в варианте форка «FkRegex», который пытается сопоставить путь запрошенного URI с предоставленным регулярным выражением.

</code></pre></div></div><p>final class TkApp extends TkWrap { private static Take make() { return new TkFork( new FkRegex(“/status”, new TkStatus()) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Мы можем создать многоуровневую структуру классов `TkFork`; например:

</code></pre></div></div><p>final class TkApp extends TsWrap { private static Take make() { return new TkFork( new FkRegex( “/status”, new TkFork( new FkParams(“f”, “json”, new TkStatusJSON()), new FkParams(“f”, “xml”, new TkStatusXML()) ) ) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Снова, я считаю, что это очевидно. Экземпляр `FkRegex` будет запрашивать ответ у инкапсулированного экземпляра `TkFork` и попытается получить его из того, что инкапсулировано в `FkParams`. Если HTTP-запрос `/status?f=xml`, то будет возвращен экземпляр `TkStatusXML`.

## HTTP Response

Теперь давайте обсудим структуру HTTP-ответа и его объектно-ориентированную абстракцию [`Response`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Response.html). Вот так выглядит интерфейс:

</code></pre></div></div><p>public interface Response { Iterable<String> head() throws IOException; InputStream body() throws IOException; }</String></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Выглядит очень похожим на [`Request`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html), не так ли? Ну, по большей части он идентичен, потому что структура HTTP-запроса и ответа практически идентична. Единственное отличие - это первая строка.

Есть набор полезных декораторов, которые помогают в создании ответов. Они составные, что делает их очень удобными. Например, если вы хотите создать ответ, содержащий HTML-страницу, вы составляете их таким образом:

</code></pre></div></div><p>final class TkIndex implements Take { @Override public Response act() { return new RsWithStatus( new RsWithType( new RsWithBody(“&lt;html&gt;Hello, world!&lt;/html&gt;”), “text/html” ), 200 ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
В этом примере декоратор `RsWithBody` создает ответ с телом, но без каких-либо заголовков. Затем `RsWithType` добавляет заголовок `Content-Type: text/html`. Затем `RsWithStatus` убеждается, что первая строка ответа содержит `HTTP/1.1 200 OK`.

Вы можете создавать собственные декораторы, которые могут повторно использовать уже существующие. Взгляните, как это сделано в [`RsPage`](https://github.com/yegor256/rultor/blob/1.50.2/src/main/java/com/rultor/web/RsPage.java) на rultor.com.

## How About Templates?

Возвращение простых страниц "Hello, world" не является большой проблемой, как мы можем видеть. Но что насчет более сложного вывода, такого как HTML-страницы, XML-документы, наборы данных JSON и т. д.? Есть несколько удобных декораторов `Response`, которые позволяют делать все это. Давайте начнем с [Velocity](http://velocity.apache.org), простого шаблонизатора. Что ж, он не такой простой. Он довольно мощный, но я бы рекомендовал использовать его только в простых ситуациях. Вот как это работает:

</code></pre></div></div><p>final class TkIndex implements Take { @Override public Response act() { return new RsVelocity(“Hello, ${name}”) .with(“name”, “Jeffrey”); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Конструктор [`RsVelocity`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/rs/RsVelocity.html) принимает единственный аргумент, который должен быть шаблоном Velocity. Затем вы вызываете метод `with()`, внедряя данные в контекст Velocity. Когда наступает время отображения HTTP-ответа, `RsVelocity` будет "оценивать" шаблон на основе настроек контекста. Опять же, я рекомендую использовать этот подход для простых выводов.

Для более сложных HTML-документов я рекомендую использовать XML/XSLT в сочетании с Xembly. Я объяснил эту идею в нескольких предыдущих постах: XML+XSLT в браузере и RESTful API и веб-сайт в одном URL. Это просто и мощно — Java генерирует XML-вывод, а процессор XSLT превращает его в HTML-документы. Так мы отделяем представление от данных. XSL-шаблон является "представлением", а `TkIndex` — "контроллером" с точки зрения MVC.

Я скоро напишу отдельную статью о шаблонизации с использованием Xembly и XSL.

В то же время мы создадим декораторы для [JSF/Facelets](http://en.wikipedia.org/wiki/Facelets) и [JSP](http://en.wikipedia.org/wiki/JavaServer_Pages) рендеринга в Takes. Если вы заинтересованы в помощи, пожалуйста, форкните фреймворк и отправьте свои pull request'ы.

## What About Persistence?

Теперь возникает вопрос о том, что делать с постоянными сущностями, такими как базы данных, структуры в памяти, сетевые соединения и т.д. Мое предложение заключается в том, чтобы инициализировать их внутри класса `Entry` и передавать их в качестве аргументов в конструктор `TkApp`. Затем `TkApp` будет передавать их в конструкторы пользовательских *takes*.

Например, у нас есть база данных PostgreSQL, которая содержит некоторые данные таблицы, которые нам необходимо отобразить. Вот как я бы инициализировал соединение с ней в классе `Entry` (я использую пул соединений [BoneCP](http://www.jolbox.com/)):

</code></pre></div></div><p>public final class Entry { public static void main(final String… args) throws Exception { new FtCli(new TkApp(Entry.postgres()), args).start(Exit.NEVER); } private static Source postgres() { final BoneCPDataSource src = new BoneCPDataSource(); src.setDriverClass(“org.postgresql.Driver”); src.setJdbcUrl(“jdbc:postgresql://localhost/db”); src.setUser(“root”); src.setPassword(“super-secret-password”); return src; } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Теперь, конструктору `TkApp` должен принимать единственный аргумент типа `java.sql.Source`:

</code></pre></div></div><p>final class TkApp extends TkWrap { TkApp(final Source source) { super(TkApp.make(source)); } private static Take make(final Source source) { return new TkFork( new FkRegex(“/”, new TkIndex(source)) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Класс `TkIndex` также принимает единственный аргумент класса `Source`. Я думаю, вы знаете, что с ним делать внутри `TkIndex`, чтобы получить данные таблицы SQL и преобразовать их в HTML. Здесь суть в том, что зависимость должна быть внедрена в приложение (экземпляр класса `TkApp`) в момент его создания. Это чистый и чистый механизм внедрения зависимостей, который абсолютно свободен от контейнеров. Подробнее об этом можно прочитать в статье "Dependency Injection Containers Are Code Polluters".

## Unit Testing

Поскольку каждый класс является неизменяемым, а все зависимости внедряются только через конструкторы, модульное тестирование очень легко. Допустим, мы хотим протестировать `TkStatus`, который должен возвращать HTML-ответ (я использую [JUnit 4](http://junit.org/) и [Hamcrest](https://github.com/hamcrest/JavaHamcrest)):

</code></pre></div></div><p>import org.junit.Test; import org.hamcrest.MatcherAssert; import org.hamcrest.Matchers; public final class TkIndexTest { @Test public void returnsHtmlPage() throws Exception { MatcherAssert.assertThat( new RsPrint( new TkStatus().act(new RqFake()) ).printBody(), Matchers.equalsTo(“&lt;html&gt;Hello, world!&lt;/html&gt;”) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Также мы можем запустить всё приложение или любую отдельную *задачу* на тестовом HTTP-сервере и проверить его поведение через реальное TCP-соединение; например (я использую [jcabi-http](http://http.jcabi.com) для выполнения HTTP-запроса и проверки вывода):

</code></pre></div></div><p>public final class TkIndexTest { @Test public void returnsHtmlPage() throws Exception { new FtRemote(new TkIndex()).exec( new FtRemote.Script() { @Override public void exec(final URI home) throws IOException { new JdkRequest(home) .fetch() .as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_OK) .assertBody(Matchers.containsString(“Hello, world!”)); } } ); } } ```</p><p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtRemote.html"><code class="language-plaintext highlighter-rouge">FtRemote</code></a> запускает тестовый веб-сервер на случайном TCP-порту и вызывает метод <code class="language-plaintext highlighter-rouge">exec()</code> на предоставленном экземпляре <code class="language-plaintext highlighter-rouge">FtRemote.Script</code>. Первым аргументом этого метода является URI только что запущенной домашней страницы веб-сервера.</p><p>Архитектура фреймворка Takes очень модульна и состоит из отдельных компонентов, которые можно комбинировать. Каждый отдельный <em>take</em> может быть протестирован как самостоятельный компонент, полностью независимый от фреймворка и других <em>takes</em>.</p><h2 id="why-the-name">Why the Name?</h2><p>Это вопрос, который я часто слышу. Идея проста и происходит из киноиндустрии. Когда делается фильм, съемочная группа делает много <em>попыток</em> для того, чтобы запечатлеть реальность и перенести ее на пленку. Каждая попытка называется <em>тейком</em>.</p><p>Другими словами, <em>take</em> - это как снимок реальности.</p><p>То же самое относится и к этой рамке. Каждый экземпляр <code class="language-plaintext highlighter-rouge">Take</code> представляет реальность в определенный момент времени. Затем эта реальность отправляется пользователю в виде <code class="language-plaintext highlighter-rouge">Response</code>.</p><p>PS. Есть несколько слов о аутентификации: Как работает аутентификация на основе куки в фреймворке Takes.</p><p>PPS. Есть несколько реальных веб-систем, которые вам может быть интересно рассмотреть. Все они используют Takes Framework и их код открытый: <a href="https://github.com/yegor256/rultor">rultor.com</a>, jare.io, wring.io.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-06 at 20:25</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?790d6e310ac"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
