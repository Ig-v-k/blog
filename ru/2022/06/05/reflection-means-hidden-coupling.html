<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Reflection Means Hidden Coupling"/> <meta name="twitter:description" property="og:description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2022/06/05/reflection-means-hidden-coupling.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?89722679c17"/> <link rel="apple-touch-icon" href="/favicon.ico?89722679c17"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?89722679c17"/> <link rel="stylesheet" href="/css/icons.css?89722679c17"/> <link rel="canonical" href="https://www.yegor256.com/ru/2022/06/05/reflection-means-hidden-coupling.html" /> <title>Reflection Means Hidden Coupling</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;386</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Reflection Means Hidden Coupling</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p><a href="https://ru.wikipedia.org/wiki/Рефлексивное_программирование">Рефлексивное программирование</a> (или рефлексия) происходит, когда ваш код изменяет себя “на лету”. Например, метод класса, когда мы его вызываем, добавляет новый метод в класс (также известный как <a href="https://ru.wikipedia.org/wiki/Monkey_patching">monkey patching</a>). Java, Python, PHP, JavaScript, назовите это — все они имеют эту “мощную” функцию. Что в этом <a href="https://softwareengineering.stackexchange.com/questions/193526">неправильно</a>? Ну, это <a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">медленно</a>, <a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">опасно</a> и трудно читать и отлаживать. Но все это ничто по сравнению с <em>связыванием</em>, которое оно вводит в код.</p><p>Существует много ситуаций, когда рефлексия может “помочь” вам. Давайте рассмотрим каждую из них и посмотрим, почему связывание, которое они добавляют к коду, является излишним и вредным.</p><h2 id="type-checking-and-casting">Type Checking and Casting</h2><p>Here is the code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}
</code></pre></div></div><p>Я не уверен, что все согласятся с тем, что это отражение, но я верю, что это так: мы проверяем структуру класса во время выполнения, а затем вызываем метод <code class="language-plaintext highlighter-rouge">size()</code>, которого нет в <code class="language-plaintext highlighter-rouge">Iterable</code>. Этот метод появляется только во время выполнения, когда мы создаем <a href="https://stackoverflow.com/questions/19017258">динамическое сокращение</a> к нему в байт-коде.</p><p>Почему это плохо, помимо того факта, что 1) это <a href="http://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">медленно</a>, 2) это более громоздко и, таким образом, <a href="https://armedia.com/blog/instanceof-avoid-in-code/">менее читаемо</a>, и 3) это вводит новую точку отказа, поскольку объект <code class="language-plaintext highlighter-rouge">items</code> может не быть экземпляром класса <code class="language-plaintext highlighter-rouge">Collection</code>, что приведет к <a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="language-plaintext highlighter-rouge">MethodNotFoundException</code></a>?</p><p>Самая большая проблема, которую код выше вызывает для всей программы, заключается в связи, которую он вводит между самим собой и его клиентами, например:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void calc(Iterable&lt;?&gt; list) {
  int s = sizeOf(list);
  System.out.println("The size is " + s);
}
</code></pre></div></div><p>Этот метод может сработать или не сработать. Это будет зависеть от фактического класса <code class="language-plaintext highlighter-rouge">list</code>. Если это <code class="language-plaintext highlighter-rouge">Collection</code>, вызов <code class="language-plaintext highlighter-rouge">sizeOf</code> будет успешным. В противном случае произойдет сбой времени выполнения. Изучая метод <code class="language-plaintext highlighter-rouge">calc</code>, мы не можем определить правильный способ обработки <code class="language-plaintext highlighter-rouge">list</code>, чтобы избежать сбоя времени выполнения. Нам нужно прочитать тело <code class="language-plaintext highlighter-rouge">sizeOf</code>, и только после этого мы можем изменить <code class="language-plaintext highlighter-rouge">calc</code> на нечто подобное этому:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void calc(Iterable&lt;?&gt; list) {
  if (list instanceof Collection) {
    int s = sizeOf(list);
    System.out.println("The size is " + s);
  } else {
    System.out.println("The size is unknown");
  }
}
</code></pre></div></div><p>Этот код пока кажется нормальным. Однако, что произойдет, когда <code class="language-plaintext highlighter-rouge">sizeOf</code> изменит свою реализацию на что-то вроде этого (я взял это из этой статьи о приведении типов):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  int size = 0;
  if (items instanceof Collection) {
    size = ((Collection) items).size();
  } else {
    for (Object item : items) {
      ++size;
    }
  }
  return size;
}
</code></pre></div></div><p>Теперь <code class="language-plaintext highlighter-rouge">sizeOf</code> отлично обрабатывает любой тип, который поступает, будь то экземпляр <code class="language-plaintext highlighter-rouge">Collection</code> или нет. Однако метод <code class="language-plaintext highlighter-rouge">calc</code> не знает о изменениях, внесенных в метод <code class="language-plaintext highlighter-rouge">sizeOf</code>. Вместо этого он все еще считает, что <code class="language-plaintext highlighter-rouge">sizeOf</code> сломается, если получит что-то, кроме <code class="language-plaintext highlighter-rouge">Collection</code>. Чтобы держать их в синхронизации, нам нужно помнить, что <code class="language-plaintext highlighter-rouge">calc</code> слишком много знает о <code class="language-plaintext highlighter-rouge">sizeOf</code> и должен будет изменяться, когда изменяется <code class="language-plaintext highlighter-rouge">sizeOf</code>. Таким образом, можно сказать, что <code class="language-plaintext highlighter-rouge">calc</code> связан с <code class="language-plaintext highlighter-rouge">sizeOf</code>, и эта связь <em>скрыта</em>: скорее всего, мы забудем изменить <code class="language-plaintext highlighter-rouge">calc</code>, когда <code class="language-plaintext highlighter-rouge">sizeOf</code> получит лучшую реализацию. Более того, в программе может быть много других мест, подобных <code class="language-plaintext highlighter-rouge">calc</code>, о которых мы должны помнить, чтобы изменить их, когда метод <code class="language-plaintext highlighter-rouge">sizeOf</code> меняется. Очевидно, мы забудем о большинстве из них.</p><p>Эта связь, которая является значительной проблемой сопровождаемости, была введена благодаря самому существованию рефлексии в Java. Если бы мы не могли использовать оператор <code class="language-plaintext highlighter-rouge">instanceof</code> и приведение классов (или даже не имели их), такая связь вообще не была бы возможна.</p><h2 id="forceful-testing">Forceful Testing</h2><p>Consider this code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}
</code></pre></div></div><p>Как бы вы написали модульный тест для этого класса и для его метода <code class="language-plaintext highlighter-rouge">print()</code>? Очевидно, это практически невозможно без рефакторинга класса. Метод <code class="language-plaintext highlighter-rouge">print</code> отправляет текст на консоль, который нельзя легко замокать, так как он “статический”. Правильным путем было бы сделать <code class="language-plaintext highlighter-rouge">System.out</code> внедряемым в качестве зависимости, но некоторые из нас <a href="https://stackoverflow.com/questions/34571">верят</a>, что рефлексия является лучшим вариантом, что позволило бы нам напрямую тестировать приватный метод <code class="language-plaintext highlighter-rouge">name</code>, не вызывая сначала <code class="language-plaintext highlighter-rouge">print</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class BookTest {
  @Test
  void testNamingWorks() {
    Book b = new Book(
      "David West", "Object Thinking"
    );
    Method m = book.getClass().getDeclaredMethod("name");
    m.setAccessible(true);
    assertThat(
      (String) m.invoke(book),
      equalTo("Object Thinking by David West")
    );
  }
}
</code></pre></div></div><p>Вы также можете использовать библиотеку Java <a href="https://github.com/powermock/powermock">PowerMock</a>, чтобы делать много «красивых» вещей с приватными методами.</p><p>Проблема этого теста заключается в том, что он тесно связан с объектом, который он проверяет: тест <em>знает</em> слишком много о классе <code class="language-plaintext highlighter-rouge">Book</code>. Тест знает, что класс содержит приватный метод <code class="language-plaintext highlighter-rouge">name</code>. Тест также знает, что метод <code class="language-plaintext highlighter-rouge">name</code> в какой-то момент будет вызван методом <code class="language-plaintext highlighter-rouge">print</code>. Вместо того, чтобы проверять <code class="language-plaintext highlighter-rouge">print</code>, тест проверяет то, о чем не должен быть осведомлен: внутренние детали класса <code class="language-plaintext highlighter-rouge">Book</code>.</p><p>Основная цель модульного тестирования - быть «подушкой безопасности» для нас, программистов, пытающихся изменить код, написанный ранее или намного ранее: если мы что-то сломаем, тесты дадут нам своевременный сигнал, «подсвечивая» место, где код был испорчен. Если ничего не выделено и тесты зеленые, я могу продолжать изменять код. Я полагаюсь на информацию от своих тестов. Я доверяю им.</p><p>Я беру класс <code class="language-plaintext highlighter-rouge">Book</code> и хочу его изменить, просто сделав метод <code class="language-plaintext highlighter-rouge">name</code> возвращающим <code class="language-plaintext highlighter-rouge">StringBuilder</code> вместо <code class="language-plaintext highlighter-rouge">String</code>. Это довольно невинное изменение, которое может быть необходимо с учетом производительности. Прежде чем я начну вносить какие-либо изменения, я запускаю все тесты (это <a href="https://wiki.c2.com/?TestEveryRefactoring">хорошая практика</a>) и они все проходят. Затем я вношу свои изменения, ожидая, что никакие тесты не провалятся:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  // ...
  public void print() {
    System.out.println(
      "The book is: " + this.name().toString()
    );
  }
  private StringBuilder name() {
    return new StringBuilder()
      .append(this.title)
      .append(" by ")
      .append(this.author);
  }
}
</code></pre></div></div><p>Однако, тест <code class="language-plaintext highlighter-rouge">BookTest</code> провалится, потому что он <em>ожидает</em>, что мой класс <code class="language-plaintext highlighter-rouge">Book</code> будет иметь метод <code class="language-plaintext highlighter-rouge">name</code>, который возвращает <code class="language-plaintext highlighter-rouge">String</code>. Если это не мой тест или я написал его давно, мне было бы раздражительно узнать об этом факте: тест ожидает, что я напишу свои <em>приватные</em> методы только одним конкретным способом. Почему? Что не так с возвращением <code class="language-plaintext highlighter-rouge">StringBuilder</code>? Я бы подумал, что есть какая-то скрытая причина для этого. В противном случае, почему бы тесту требовать что-либо от приватной реализации класса? Очень скоро, после некоторого исследования, я бы узнал, что причины отсутствуют. Это просто предположение, которое тест сделал о внутренностях <code class="language-plaintext highlighter-rouge">Book</code>, и это предположение не имеет никаких обоснований, кроме “У нас не было времени для рефакторинга класса и создания возможности подключения <code class="language-plaintext highlighter-rouge">System.out</code>”.</p><p>Кстати, такой подход к тестированию известен как анти-паттерн “Inspector” тест.</p><p>Что бы я делал дальше? Мне придется откатить свои изменения, а затем начать рефакторинг теста <em>и</em> класса, чтобы избавиться от этого предположения. Однако, изменение теста и одновременное изменение основного кода, <a href="https://twitter.com/yegor256/status/1525758255225528320">по моему мнению</a>, является <a href="https://stackoverflow.com/questions/1569168">опасной практикой</a>: вероятно, я внесу новые ошибки.</p><p>Тесты больше не являются для меня “защитной сеткой”. Я не могу им доверять. Я меняю код и знаю, что ничего не сломал. Однако тест показывает мне красный сигнал. Как я могу ему доверять, если он лжет даже в таком простом сценарии?</p><p>Это связь между модульным тестом <code class="language-plaintext highlighter-rouge">BookTest</code> и классом <code class="language-plaintext highlighter-rouge">Book</code> не произошла бы, если бы не было возможности использовать рефлексию в первую очередь. Если у кого-то не было бы возможности достичь приватного метода любым способом, тогда анти-паттерн “Инспектор” в модульных тестах был бы невозможен.</p><p>Конечно же, жизнь была бы еще лучше, если бы у нас не было и приватных методов.</p><h2 id="factories">Factories</h2><p>Вот как может работать типичный завод:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Operator {
  int calc(int a, int b);
}
// This is a Factory Method:
Operator make(String name) {
  try {
    return Class.forName("Op" + name);
  } catch (ClassNotFoundException ex) {
    throw new IllegalStateException(ex);
  }
}
</code></pre></div></div><p>Фабричный метод - это <code class="language-plaintext highlighter-rouge">make</code>. Он ожидает предоставления имени “оператора” и затем, используя <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code class="language-plaintext highlighter-rouge">Class.forName()</code></a> из Java Reflection API, создает имя класса, находит его в <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">classpath</a> и создает экземпляр этого класса. Предположим, есть два класса, оба реализующих интерфейс <code class="language-plaintext highlighter-rouge">Operator</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OpPlus implements Operator {
  int calc(int a, int b) {
    return a + b;
  }
}
class OpMinus implements Operator {
  int calc(int a, int b) {
    return a - b;
  }
}
</code></pre></div></div><p>Затем мы их используем, сначала запрашивая у нашего фабричного метода создание объектов по именам операторов.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int result = make("Plus").calc(
  make("Minus").calc(15, 3),
  make("Minus").calc(8, 7)
);
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">result</code> будет равно 13.</p><p>Мы не смогли бы сделать это без размышлений. Вместо этого мы должны были бы сделать это:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int result = new OpPlus().calc(
  new OpMinus().calc(15, 3),
  new OpMinus().calc(8, 7)
);
</code></pre></div></div><p>Если спросите меня, этот код выглядит гораздо более читаемым и поддерживаемым. Во-первых, потому что в любой среде разработки, которая поддерживает <a href="https://www.jetbrains.com/help/idea/navigating-through-the-source-code.html#go_to_declaration">навигацию по коду</a>, можно было бы щелкнуть на <code class="language-plaintext highlighter-rouge">OpMinus</code> или <code class="language-plaintext highlighter-rouge">OpPlus</code> и сразу перейти к телу класса. Во-вторых, логика поиска класса предоставляется JVM «из коробки»: мне не нужно догадываться, что происходит при вызове <code class="language-plaintext highlighter-rouge">make("Plus")</code>.</p><p>Есть несколько причин, почему люди любят использовать статические фабрики. Я не согласен с ними. В этом блог-посте объясняется, почему. Без отражения вообще не было бы возможности использовать статические фабрики, и код был бы лучше и более поддерживаемым.</p><h2 id="annotations">Annotations</h2><p>В Java вы можете прикрепить аннотацию (экземпляр интерфейса DTO-ish) к классу (или его элементу, такому как метод или аргумент). Информацию из аннотации можно прочитать во время выполнения или времени компиляции. В современных фреймворках, таких как <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>, эта функция часто используется для автоматизации <a href="https://stackoverflow.com/questions/19414734">проводки объектов</a>: вы просто прикрепляете некоторые аннотации к вашим классам, и фреймворк найдет их, создаст экземпляры, поместит их в контейнер DI и присвоит их атрибутам других объектов.</p><p>Я уже говорил ранее, что этот самый механизм обнаружения объектов и <em>автоматического</em> их связывания является антипаттерном. Я также говорил ранее, что аннотации - это антипаттерн. Ни контейнеры внедрения зависимостей, ни автосвязывание, ни аннотации не существовали бы без отражения. Жизнь была бы намного лучше, а Java/OOP намного чище.</p><p>Клиенты аннотированных объектов/классов связаны с ними, и эта связь <em>скрыта</em>. Аннотированный объект может изменить свой интерфейс или модифицировать аннотации, и код все равно будет скомпилирован без ошибок. Проблема возникнет только позже, во время выполнения, когда ожидания других объектов не будут выполнены.</p><h2 id="serialization">Serialization</h2><p>Когда программисты не понимают объектно-ориентированную парадигму, они создают DTO вместо правильных объектов. Затем, чтобы передать DTO по сети или сохранить его в файл, они сериализуют или маршалируют его. Это обычно делается с помощью специального механизма сериализации, который берет DTO, разрушает все возможные барьеры инкапсуляции, считывает значения всех его полей и упаковывает их, скажем, в кусок JSON.</p><p>Чтобы позволить механизму сериализации преодолеть барьеры инкапсуляции, язык программирования должен иметь рефлексию. Во-первых, потому что некоторые поля объекта передачи данных (DTO) могут быть приватными и, следовательно, доступными только через рефлексию. Во-вторых, даже если DTO разработан «правильно» с необходимыми методами доступа к приватным полям, все равно требуется использование рефлексии, чтобы понять, какие методы доступа присутствуют и могут быть вызваны.</p><p>Сериализация относится к объектам очень похожим образом, как это делает ORM. Ни одно из них не общается с объектами, а вместо этого они “насильно” разбирают их, забирая нужное и оставляя бедные объекты без сознания. Если в будущем объект решит изменить свою структуру, переименовать некоторые поля или изменить типы возвращаемых значений, другие объекты, которые связаны с ним через сериализацию, ничего не заметят. Они заметят это только во время выполнения, когда начнут возникать исключения “неверный формат данных”. Разработчикам объекта не будет дана возможность заметить, что их изменения в интерфейсе объекта затрагивают другие места в кодовой базе.</p><p>Мы можем сказать, что сериализация является “идеальным” методом связывания двух объектов таким образом, что ни один из них о ней не будет знать.</p><p>Сама идея объектно-ориентированного программирования основана на принципе, что объект - король. Объект и только объект решает, что делать с данными, которые он инкапсулирует. Существование этого принципа и его соблюдение помогают избежать ошибок времени выполнения, обычно вызванных простым сценарием: А использует данные, поступающие от В, не сообщая В, как они используются, затем В изменяет формат или семантику данных, и А не понимает их.</p><p>Очевидно, что сериализация в таком “насильственном” виде была бы невозможна, если бы не было рефлексии в первую очередь. Более аккуратная сериализация возможна и используется не через рефлексию, а с помощью принтеров, реализованных объектами.</p><hr /><p>To conclude, reflection introduces coupling, which is hidden. This is the most dangerous type of coupling, because it’s hard to follow, it’s hard to find, and it’s hard to remove. Without reflection object-oriented design would be much cleaner and solid. But even if this feature does exist, I suggest you never use reflection in your programming language.</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Do you use reflective programming (reflection)?</p>&mdash; Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1535919879886446592?ref_src=twsrc%5Etfw">June 12, 2022</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/31 on 2023-08-29 at 18:49</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?89722679c17"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
