<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Reflection Means Hidden Coupling"/> <meta name="twitter:description" property="og:description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2022/06/05/reflection-means-hidden-coupling.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d7375766803"/> <link rel="apple-touch-icon" href="/favicon.ico?d7375766803"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d7375766803"/> <link rel="stylesheet" href="/css/icons.css?d7375766803"/> <link rel="canonical" href="https://www.yegor256.com/ru/2022/06/05/reflection-means-hidden-coupling.html" /> <title>Reflection Means Hidden Coupling</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Reflection Means Hidden Coupling</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p><a href="https://en.wikipedia.org/wiki/Reflective_programming">Рефлексивное программирование</a> (или рефлексия) происходит, когда ваш код меняется сам по себе во время выполнения. Например, метод класса, когда мы вызываем его, добавляет новый метод в класс (также известный как <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>). Java, Python, PHP, JavaScript, назовите их—все они обладают этой “мощной” возможностью. Что с этим <a href="https://softwareengineering.stackexchange.com/questions/193526">неправильно</a>? Ну, это <a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">медленно</a>, <a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">опасно</a> и сложно читать и отлаживать. Но все это ничто по сравнению с <em>связностью</em>, которую оно вносит в код.</p><p>Есть много ситуаций, когда рефлексия может “помочь” вам. Давайте рассмотрим все из них и посмотрим, почему связность, которую они добавляют в код, является ненужной и вредной.</p><p>Here is the code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}
</code></pre></div></div><p>Я не уверен, что все согласятся с тем, что это рефлексия, но я считаю, что это так: мы проверяем структуру класса во время выполнения, а затем вызываем метод <code class="language-plaintext highlighter-rouge">size()</code>, который не существует в <code class="language-plaintext highlighter-rouge">Iterable</code>. Этот метод появляется только во время выполнения, когда мы создаем <a href="https://stackoverflow.com/questions/19017258">динамическую ссылку</a> на него в байт-коде.</p><p>Почему это плохо, помимо того факта, что 1) это <a href="http://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">медленно</a>, 2) это более многословно и, следовательно, <a href="https://armedia.com/blog/instanceof-avoid-in-code/">менее читабельно</a>, и 3) это вводит новую точку отказа, так как объект <code class="language-plaintext highlighter-rouge">items</code> может не быть экземпляром класса <code class="language-plaintext highlighter-rouge">Collection</code>, что может привести к <a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="language-plaintext highlighter-rouge">MethodNotFoundException</code></a>?</p><p>Самая большая проблема, которую код выше вызывает для всей программы, - это связь, которую он создает между собой и своими клиентами, например:</p><p>Этот метод может сработать или не сработать. Это будет зависеть от фактического класса <code class="language-plaintext highlighter-rouge">list</code>. Если это <code class="language-plaintext highlighter-rouge">Collection</code>, вызов <code class="language-plaintext highlighter-rouge">sizeOf</code> будет успешным. В противном случае произойдет сбой во время выполнения. Просматривая метод <code class="language-plaintext highlighter-rouge">calc</code>, мы не можем определить правильный способ обработки <code class="language-plaintext highlighter-rouge">list</code>, чтобы избежать сбоя во время выполнения. Нам нужно прочитать тело <code class="language-plaintext highlighter-rouge">sizeOf</code> и только после этого мы можем изменить <code class="language-plaintext highlighter-rouge">calc</code> на что-то вроде этого:</p><p>Этот код пока кажется нормальным. Однако, что произойдет, когда <code class="language-plaintext highlighter-rouge">sizeOf</code> изменит свою реализацию на что-то подобное (я взял это из статьи о приведении типов):</p><p>Теперь <code class="language-plaintext highlighter-rouge">sizeOf</code> отлично справляется с любым типом, который поступает, будь то экземпляр <code class="language-plaintext highlighter-rouge">Collection</code> или нет. Однако метод <code class="language-plaintext highlighter-rouge">calc</code> не знает о изменениях, внесенных в метод <code class="language-plaintext highlighter-rouge">sizeOf</code>. Вместо этого он все еще считает, что <code class="language-plaintext highlighter-rouge">sizeOf</code> сломается, если ему передать что-то, кроме <code class="language-plaintext highlighter-rouge">Collection</code>. Чтобы держать их в синхронизации, нам нужно помнить о том, что <code class="language-plaintext highlighter-rouge">calc</code> слишком много знает о <code class="language-plaintext highlighter-rouge">sizeOf</code> и придется изменять его при изменении <code class="language-plaintext highlighter-rouge">sizeOf</code>. Таким образом, можно сказать, что <code class="language-plaintext highlighter-rouge">calc</code> связан с <code class="language-plaintext highlighter-rouge">sizeOf</code>, и эта связь <em>скрытая</em>: скорее всего, мы забудем изменить <code class="language-plaintext highlighter-rouge">calc</code>, когда <code class="language-plaintext highlighter-rouge">sizeOf</code> получит лучшую реализацию. Более того, в программе может быть много других мест, похожих на <code class="language-plaintext highlighter-rouge">calc</code>, о которых мы должны помнить, чтобы изменить их при изменении метода <code class="language-plaintext highlighter-rouge">sizeOf</code>. Очевидно, что мы забудем о большинстве из них.</p><p>Эта связь, которая является серьезной проблемой поддержки, была введена благодаря самому существованию рефлексии в Java. Если бы мы не могли использовать оператор <code class="language-plaintext highlighter-rouge">instanceof</code> и приведение типов (или даже не имели их), связь вообще не была бы возможна.</p><p>Consider this code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}
</code></pre></div></div><p>Как бы вы написали модульный тест для этого класса и для его метода <code class="language-plaintext highlighter-rouge">print()</code>? Очевидно, это почти невозможно без рефакторинга класса. Метод <code class="language-plaintext highlighter-rouge">print</code> отправляет текст в консоль, который нельзя легко имитировать, так как он “статический”. Правильным путем было бы сделать <code class="language-plaintext highlighter-rouge">System.out</code> внедряемым в качестве зависимости, но некоторые из нас <a href="https://stackoverflow.com/questions/34571">считают</a>, что лучшим вариантом является использование рефлексии, что позволит нам тестировать приватный метод <code class="language-plaintext highlighter-rouge">name</code> напрямую, без предварительного вызова <code class="language-plaintext highlighter-rouge">print</code>.</p><p>Вы также можете использовать библиотеку Java <a href="https://github.com/powermock/powermock">PowerMock</a>, чтобы делать много “красивых” вещей с приватными методами.</p><p>Проблема этого теста в том, что он тесно связан с объектом, который он тестирует: тест <em>знает</em> слишком много о классе <code class="language-plaintext highlighter-rouge">Book</code>. Тест знает, что класс содержит приватный метод <code class="language-plaintext highlighter-rouge">name</code>. Тест также знает, что метод <code class="language-plaintext highlighter-rouge">name</code> будет вызван методом <code class="language-plaintext highlighter-rouge">print</code>. Вместо того, чтобы тестировать <code class="language-plaintext highlighter-rouge">print</code>, тест проверяет то, о чем он не должен знать: внутренности класса <code class="language-plaintext highlighter-rouge">Book</code>.</p><p>Основная цель модульного тестирования - быть “сетью безопасности” для нас, программистов, пытающихся изменить код, написанный ранее или намного раньше: если мы что-то сломаем, тесты дадут нам своевременный сигнал, “подсветив” место, где код был сломан. Если ничего не подсвечено, и тесты проходят успешно, я могу продолжать изменять код. Я полагаюсь на информацию от своих тестов. Я доверяю им.</p><p>Я беру класс <code class="language-plaintext highlighter-rouge">Book</code> и хочу изменить его, просто вернув из метода <code class="language-plaintext highlighter-rouge">name</code> <code class="language-plaintext highlighter-rouge">StringBuilder</code> вместо <code class="language-plaintext highlighter-rouge">String</code>. Это довольно невинное изменение, которое может быть необходимо с точки зрения производительности. Прежде чем я начну вносить какие-либо изменения, я запускаю все тесты (это <a href="https://wiki.c2.com/?TestEveryRefactoring">хорошая практика</a>) и они все проходят успешно. Затем я вношу свои изменения, ожидая, что ни один из тестов не сломается.</p><p>Однако тест <code class="language-plaintext highlighter-rouge">BookTest</code> не пройдет, потому что он <em>ожидает</em>, что у моего класса <code class="language-plaintext highlighter-rouge">Book</code> будет метод <code class="language-plaintext highlighter-rouge">name</code>, который возвращает <code class="language-plaintext highlighter-rouge">String</code>. Если это не мой тест или я написал его очень давно, я был бы раздражен узнать об этом факте: тест ожидает, что я напишу свои <em>приватные</em> методы только одним определенным способом. Почему? Что не так с возвратом <code class="language-plaintext highlighter-rouge">StringBuilder</code>? Я бы подумал, что есть какая-то скрытая причина для этого. В противном случае, почему бы тесту требовать что-либо от приватной реализации класса? Очень скоро, после некоторого исследования, я бы узнал, что причины нет. Это просто предположение, которое тест сделал о внутренностях <code class="language-plaintext highlighter-rouge">Book</code>, и это предположение не имеет никаких причин, кроме “У нас не было времени перестроить класс и сделать <code class="language-plaintext highlighter-rouge">System.out</code> внедряемым”.</p><p>Кстати, такой подход к тестированию известен как анти-паттерн “Инспектор”.</p><p>Что я буду делать дальше? Мне придется откатить свои изменения и затем начать рефакторинг теста <em>и</em> класса, чтобы избавиться от этого предположения. Однако изменение теста и одновременное изменение основного кода - это, <a href="https://twitter.com/yegor256/status/1525758255225528320">я считаю</a>, <a href="https://stackoverflow.com/questions/1569168">опасная практика</a>: скорее всего, я внесу новые ошибки.</p><p>Тесты больше не являются для меня “сетью безопасности”. Я не могу доверять им. Я изменяю код и знаю, что ничего не сломал. Однако тест дает мне красный сигнал. Как мне ему доверять, если он лжет в таком простом сценарии?</p><p>Такая связь между модульным тестом <code class="language-plaintext highlighter-rouge">BookTest</code> и классом <code class="language-plaintext highlighter-rouge">Book</code> не возникла бы, если бы нельзя было использовать рефлексию вообще. Если бы никто не имел возможности обратиться к приватному методу никаким образом, анти-паттерн “Инспектор” в модульных тестах не был бы возможен.</p><p>Конечно, жизнь была бы еще лучше, если бы у нас не было приватных методов.</p><p>Вот как может работать типичный завод:</p><p>Фабричный метод называется <code class="language-plaintext highlighter-rouge">make</code>. Он ожидает, что будет предоставлено имя “operator” и затем, используя <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code class="language-plaintext highlighter-rouge">Class.forName()</code></a> из Java Reflection API, конструирует имя класса, находит его в <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">classpath</a> и создает его экземпляр. Предположим теперь, что есть два класса, оба реализующих интерфейс <code class="language-plaintext highlighter-rouge">Operator</code>:</p><p>Затем мы используем их, сначала обращаясь к нашему фабричному методу, чтобы создавать объекты по имени операторов.</p><p><code class="language-plaintext highlighter-rouge">result</code> получится 13.</p><p>Мы не смогли бы сделать это без отражения. Вместо этого, нам пришлось бы сделать следующее:</p><p>Если спросите меня, этот код выглядит намного более читаемым и поддерживаемым. Во-первых, потому что в любой IDE, которая позволяет <a href="https://www.jetbrains.com/help/idea/navigating-through-the-source-code.html#go_to_declaration">навигацию по коду</a>, можно было бы щелкнуть по <code class="language-plaintext highlighter-rouge">OpMinus</code> или <code class="language-plaintext highlighter-rouge">OpPlus</code> и сразу перейти к телу класса. Во-вторых, логика поиска класса предоставляется JVM “из коробки”: мне не нужно догадываться, что происходит при вызове <code class="language-plaintext highlighter-rouge">make("Plus")</code>.</p><p>Есть несколько причин, почему люди любят статические фабрики. Я не согласен с ними. В этой блог-посте объясняется, почему. Без использования рефлексии статические фабрики вообще были бы невозможны, и код был бы лучше и более управляемым.</p><p>На Java можно прикрепить аннотацию (экземпляр интерфейса DTO) к классу (или его элементу, такому как метод или аргумент). Информацию из аннотации можно прочитать во время выполнения или на этапе компиляции. В современных фреймворках, например, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>, эта функция часто используется для автоматизации <a href="https://stackoverflow.com/questions/19414734">проводки объектов</a>: вы просто прикрепляете некоторые аннотации к своим классам, и фреймворк найдет их, создаст их, поместит их в контейнер DI и присвоит их атрибутам других объектов.</p><p>Ранее я уже говорил, что этот механизм обнаружения объектов и <em>автоматической</em> их связи является анти-паттерном. Я также уже говорил, что аннотации - это анти-паттерн. Ни контейнеры внедрения зависимостей, ни автоматическая проводка, ни аннотации не существовали бы, если бы не было рефлексии. Жизнь была бы намного лучше, и Java/OOP была бы гораздо чище.</p><p>Клиенты аннотированных объектов/классов связаны с ними, и эта связь <em>скрыта</em>. Аннотированный объект может изменить свой интерфейс или изменить аннотации, и код все равно будет компилироваться. Проблема возникнет только позже, во время выполнения, когда ожидания других объектов не будут выполнены.</p><p>Когда программисты не понимают объектно-ориентированную парадигму, они создают объекты DTO вместо правильных объектов. Затем, чтобы передать объект DTO по сети или сохранить его в файл, они сериализуют или маршализуют его. Обычно это делается с помощью специального механизма сериализации, который берет объект DTO, преодолевает все возможные барьеры инкапсуляции, считывает значения всех его полей и упаковывает их, скажем, в JSON.</p><p>Чтобы механизм сериализации мог преодолеть барьеры инкапсуляции, язык программирования должен иметь рефлексию. Во-первых, потому что некоторые поля объекта DTO могут быть приватными и доступными только через рефлексию. Во-вторых, даже если объект DTO разработан “правильно” с необходимыми геттерами для приватных полей, все равно требуется рефлексия, чтобы понять, какие геттеры присутствуют и могут быть вызваны.</p><p>Отношение сериализации к объектам очень похоже на то, что делает ORM. Ни один из них не работает с объектами напрямую, а, наоборот, “насильственно” разбирает их, забирая только то, что необходимо, и оставляя бедные объекты без сознания. Если в будущем объект решит изменить свою структуру, переименовать некоторые поля или изменить типы возвращаемых значений, другие объекты, фактически связанные с объектом через сериализацию, ничего не заметят. Они заметят это только во время выполнения, когда начнут возникать исключения “неверный формат данных”. Разработчики объекта не смогут заметить, что их изменения в интерфейсе объекта влияют на другие места в кодовой базе.</p><p>Можно сказать, что сериализация - это “идеальный” способ связывания двух объектов таким образом, чтобы ни один из них не знал об этом.</p><p>Сама идея объектно-ориентированного программирования сосредоточена вокруг принципа, что объект - царь. Объект и только объект может решить, что делать с данными, которые он инкапсулирует. Существование этого принципа и его соблюдение помогает избежать ошибок времени выполнения, обычно вызванных простым сценарием: A использует данные, полученные от B, не сообщая B, как они используются, затем B меняет формат или семантику данных, и A не может их понять.</p><p>Очевидно, такая “насильственная” сериализация не была бы возможна, если бы не было рефлексии. Более осторожная сериализация была бы возможна и использовалась бы, не через рефлексию, а с помощью принтеров, реализованных объектами.</p><p>В заключение, рефлексия вводит связывание, которое скрыто. Это самый опасный тип связывания, поскольку его трудно отследить, его трудно обнаружить и его трудно удалить. Без рефлексии объектно-ориентированный дизайн был бы намного чище и надежнее. Но даже если эта возможность существует, я предлагаю вам никогда не использовать рефлексию в вашем языке программирования.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/36 on 2023-11-17 at 12:58</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d7375766803"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
