<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="While many, including Google, advocate for larger monolithic repositories, I strongly believe that the biggest repo should include fewer than 50K lines of code." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Monolithic Repos Are Evil"/> <meta name="twitter:description" property="og:description" content="While many, including Google, advocate for larger monolithic repositories, I strongly believe that the biggest repo should include fewer than 50K lines of code."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2018/09/05/monolithic-repositories.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?218873848f7"/> <link rel="apple-touch-icon" href="/favicon.ico?218873848f7"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?218873848f7"/> <link rel="stylesheet" href="/css/icons.css?218873848f7"/> <link rel="canonical" href="https://www.yegor256.com/ru/2018/09/05/monolithic-repositories.html" /> <title>Monolithic Repos Are Evil</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;385</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Monolithic Repos Are Evil</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2018/09/05/monolithic-repositories.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Мы все храним наш код в репозиториях для <del>Git</del> <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9">контроля версий</a>. Вопрос в том, следует ли нам создавать новый репозиторий для каждого нового модуля или пытаться сохранить как можно больше в одном так называемом “монолитном” репозитории (или просто <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%BE%D1%80%D0%B5%D0%BF%D0%BE">монорепо</a>). Лидеры рынка, такие как <a href="https://code.fb.com/core-data/scaling-mercurial-at-facebook/">Facebook</a> и <a href="https://www.infoq.com/presentations/Development-at-Google">Google</a>, отстаивают второй подход. Я считаю, что они ошибаются.</p><p>Давайте в качестве примера используем следующую функцию JavaScript. Она загружает JSON-документ с узла <a href="http://www.zold.io">Zold</a> (с использованием <a href="https://jquery.com/">jQuery</a>) и размещает часть его содержимого на HTML-странице. Затем она окрашивает данные в соответствии с их значением.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
function main() {
  $.getJSON('http://b1.zold.io/', function(json) {
    var $body = $('body');
    $body.text(json.nscore);
    var color = 'red';
    if (json.nscore &gt; 500) {
      color = 'green';
    }
    $body.css('color', color);
  });
}
</code></pre></div></div><p>Довольно очевидно, не так ли? Просто один файл <code class="language-plaintext highlighter-rouge">main.js</code>, который делает все, что нам нужно. Мы просто добавляем его в HTML, и он работает.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"/&gt;
    &lt;script src="main.js"/&gt;
  &lt;/head&gt;
  &lt;body onload="main();"&gt;loading...&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div><p>Теперь позвольте мне перестроить это. Разобью его на две части. Первая часть будет загружать данные, а вторая будет плагином jQuery для окрашивания содержимого HTML в соответствии с данными, которые он содержит. Вот как будет выглядеть этот плагин:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// colorize.js
$.fn.colorize = function() {
  var data = parseFloat(this.text());
  var keys = Object.keys(colors)
    .map(function (k) { return parseInt(k); })
    .sort(function (a,b) { return a - b; })
    .reverse();
  for (i = 0; i &lt; keys.length; ++i) {
    var max = keys[i];
    if (data &gt;= max) {
      this.addClass(colors[max]);
      return;
    }
    this.removeClass(colors[max]);
  }
  return this;
}
</code></pre></div></div><p>Файл <code class="language-plaintext highlighter-rouge">main.js</code> будет выглядеть так:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
function main() {
  $.getJSON('http://b1.zold.io/', function(json) {
    $('body')
      .text(json.nscore)
      .colorize({ 500: 'green', 0: 'red' });
  });
}
</code></pre></div></div><p>Теперь, вместо одного монолитного куска кода, у нас есть две меньшие части, которые должны быть загружены вместе в целевой HTML.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"/&gt;
    &lt;script src="colorize.js"/&gt;
    &lt;script src="main.js"/&gt;
  &lt;/head&gt;
  &lt;body onload="main();"&gt;loading...&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div><p>Два кусочка лучше одного? Похоже, <a href="https://ai.google/research/pubs/pub45424">Google</a>, <a href="https://blog.digitalocean.com/taming-your-go-dependencies/">Digital Ocean</a> и <a href="https://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">Mozilla</a> так не считают.</p><p>I disagree.</p><p>Чтобы проиллюстрировать свою точку зрения, я извлек функцию JavaScript в новый автономный <a href="https://github.com/yegor256/colorizejs">плагин jQuery</a>. Вот что я сделал:</p><p>Создан новый репозиторий GitHub <a href="https://github.com/yegor256/colorizejs">yegor256/colorizejs</a>;</p><p>Прочитайте <a href="https://learn.jquery.com/plugins/basic-plugin-creation/">инструкции</a>;</p><p>Провёл некоторое исследование плагинов jQuery, изучил несколько примеров;</p><p>Узнал, что большинство из них использовали <a href="https://gulpjs.com/">Gulp</a>, о котором я никогда не слышал;</p><p>Решил использовать <a href="https://www.npmjs.com/">npm</a> для упаковки JavaScript (что еще, верно?).</p><p>Создан <a href="https://github.com/yegor256/colorizejs/blob/master/package.json"><code class="language-plaintext highlighter-rouge">package.json</code></a> для npm.</p><p>Переименовал репозиторий GitHub в <code class="language-plaintext highlighter-rouge">colorizejs</code>, когда узнал(а), что уже существует пакет npm <a href="https://www.npmjs.com/package/colorize"><code class="language-plaintext highlighter-rouge">colorize</code></a>.</p><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.travis.yml"><code class="language-plaintext highlighter-rouge">.travis.yml</code></a> для <a href="https://travis-ci.org/">Travis</a>;</p><p>Создан <a href="https://github.com/yegor256/colorizejs/blob/master/README.md">README.md</a> и объяснено, как его использовать и установить.</p><p>Решил использовать лицензию MIT и создал <a href="https://github.com/yegor256/colorizejs/blob/master/LICENSE.txt">LICENSE.txt</a>;</p><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.pdd">PDD</a> для автоматического сбора <a href="">головоломок</a>.</p><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.rultor.yml"><code class="language-plaintext highlighter-rouge">.rultor.yml</code></a> для <a href="">Rultor</a>.</p><p>Попытался создать модульный тест и провалился в этом (после полного часа исследований), так как у меня почти нет опыта в модульном тестировании на JS.</p><p>Опубликовал <a href="https://stackoverflow.com/questions/51809750/">вопрос</a> на Stack Overflow;</p><p>Вопрос был ответен только несколькими людьми после того, как я предложил вознаграждение.</p><p>Ответ <a href="https://github.com/brian-lives-outdoors">@brian-lives-outdoors</a> был лучшим, и он даже предложил <a href="https://github.com/yegor256/colorizejs/pull/2">pull request</a> с юнит-тестом, который я объединил.</p><p>Выпущена первая версия <a href="https://github.com/yegor256/colorizejs/tree/0.0.1">0.0.1</a> на <a href="https://www.npmjs.com/package/colorizejs">npmjs.com</a>;</p><p>Изменил код, чтобы он работал как с классами, так и с цветами;</p><p><a href="https://github.com/yegor256/colorizejs/issues/3">Внедрена</a> и выпущена следующая версия <a href="https://github.com/yegor256/colorizejs/tree/0.1.0">0.1.0</a>;</p><p><a href="https://github.com/zold-io/zold.github.io/issues/81">Добавил</a> его во фронт-энд Zold, протестировал и выпустил—проверьте <a href="http://www.zold.io/health.html">здесь</a>.</p><p>Понадобилось почти три недели ожидания и четыре часа работы, чтобы переместить небольшой кусок кода JavaScript в новый репозиторий и выпустить его отдельно. Стоило ли это? Честно говоря, я считаю, что да. Но большинство других авторов блогов, которых мне удалось найти, считают, что лучше держать все в одном монолитном репозитории, в основном потому что это лучше для <em>продуктивности</em>. Например, <a href="https://danluu.com/monorepo/">Преимущества монорепозиториев</a> от <a href="https://twitter.com/danluu">Дэна Луу</a>, <a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">Преимущества и недостатки монолитного репозитория</a> (кейс-стади в Google) от Сиеры Джаспан и др., и <a href="https://www.tomasvotruba.cz/blog/2017/01/31/how-monolithic-repository-in-open-source-saved-my-laziness/">Как монолитный репозиторий в Open Source спас мою лень</a> от Томаса Вотрубы.</p><p>Также есть несколько хороших анализов обоих подходов, например, речь <a href="https://www.dotconferences.com/2016/05/fabien-potencier-monolithic-repositories-vs-many-repositories">Monolithic repositories vs. Many repositories</a> Фабьена Потенсье на конференции dotScale 2016 и статья <a href="http://www.gigamonkeys.com/mono-vs-multi/">Repo Style Wars: Mono vs Multi</a> Питера Сейбеля.</p><p>Вкратце, все они утверждают, что производительность выше с монолитным репозиторием, потому что количество операций, которые нужно выполнить для внесения изменений, меньше. Действительно, в монорепо будет только одна ветка, один набор коммитов, один запрос на объединение, одно развертывание и выпуск. Также будет проще тестировать, как вручную, так и с помощью модульного тестирования. Настройка непрерывной интеграции проще, и так далее.</p><p>Все эти “разумные” аргументы напоминают мне то, что я слышу, когда проповедую разделение объектов и предлагаю, что несколько объектов лучше, чем один большой. Представьте себе большой класс из 3 000 строк кода, который делает много вещей, и все они очень плотно связаны. “Легко” тестировать его, вносить изменения, развертывать, рецензировать и т. д. Потому что все находится в одном файле, верно? Нам не нужно переходить от класса к классу, чтобы понять дизайн. Мы просто смотрим на один экран, прокручиваем его вверх и вниз, и это все. Верно? Абсолютно нет!</p><p>Думаю, мне не нужно объяснять, почему это неправильно. Мы больше не проектируем наше программное обеспечение таким образом. Мы знаем, что плотное связывание - плохая идея. Мы знаем, что набор из меньших компонентов лучше, чем большой сплошной блок.</p><p>Почему мы не можем применить ту же логику к репозиториям? Я считаю, что можем. Конечно, точно так же, как в объектно-ориентированном программировании, утонченный дизайн требует больше навыков и времени. Посмотрите, что мне пришлось сделать с этим небольшим плагином jQuery. Я потратил много часов на кодирование и размышления. Мне даже пришлось изучить <a href="https://gulpjs.com/">Gulp</a> и <a href="https://jasmine.github.io/">Jasmine</a>, которые, скорее всего, больше не пригодятся мне. Но преимущества, которые мы получаем от этого, огромны. Вот мой короткий список из них:</p><p><strong>Инкапсуляция</strong>. Каждый репозиторий инкапсулирует одну проблему, скрывая ее детали от всех остальных. Благодаря этому, область, с которой должен иметь дело каждый репозиторий, становится меньше. Чем меньше область, как в объектно-ориентированном программировании, тем проще ее поддерживать и модифицировать. Чем проще поддерживать, тем дешевле разработка. Полагаю, ребята из Google действительно не беспокоятся о затратах. Напротив, они хотят, чтобы их зарплаты росли. Большой неуправляемый монолитный репозиторий - идеальный инструмент для реализации этой цели.</p><p><strong>Быстрые сборки</strong>. Когда репозиторий небольшой, время, затрачиваемое на автоматическую сборку, тоже небольшое. Посмотрите на время, которое <a href="https://travis-ci.org/yegor256/colorizejs/builds/420726284">Трэвис</a> тратит на сборку моего плагина jQuery. Это 51 секунда. Это быстро. Мы <a href="https://mortoray.com/2015/05/06/fast-build-turnaround-time-is-essential/">все знаем</a>, что чем быстрее сборка, тем лучше для продуктивности, поскольку проще использовать сборку в качестве инструмента для разработки.</p><p><strong>Точные показатели</strong>. Я не знаю, полагаетесь ли вы на метрики в своих проектах, но мы в <a href="https://www.zerocracy.com">Zerocracy</a> обращаем внимание на числа, такие как количество строк кода, <a href="">количество исполнений кода</a>, количество коммитов, классы, методы, сплоченность, связанность и т.д. Всегда возникает вопрос о точности этих метрик. Расчет количества строк кода для большого репозитория не имеет смысла, поскольку это число будет включать множество файлов из абсолютно разных частей приложения. Более того, там будут разные языки и форматы файлов. Предположим, что в репозитории есть 200 тысяч строк Java, 150 тысяч строк XML, 50 тысяч строк JavaScript и 40 тысяч строк Ruby. Вы можете сказать что-то конкретное об этом репозитории? Он большой? Это Java-репозиторий? И, что более важно, его можно сравнить с другими репозиториями? На самом деле, нет. Это просто большое беспорядочное хранилище файлов.</p><p><strong>Однородные задачи</strong>. В небольших репозиториях обычно используются более ограниченные технологические стеки, что означает, что каждый из них использует только несколько языков и фреймворков или (и это предпочтительная ситуация) - один язык или технологию на один репозиторий. Благодаря этому управление программистами становится проще, поскольку любая задача или проблема может быть поручена любому. Легче создавать задачи схожего размера и сложности. Это, очевидно, означает более управляемый проект.</p><p><strong>Единый стандарт кодирования</strong>. Более просто стандартизировать стиль кодирования, если репозиторий небольшой. Когда он большой, различные части кодовой базы будут иметь разные стили, и почти невозможно будет привести всех к общему знаменателю. Другими словами, более маленькие репозитории выглядят более красиво, чем более крупные.</p><p><strong>Короткие имена</strong>. В каждом репозитории неизбежно будет свое собственное пространство имен. Например, в только что созданном репозитории JS у меня есть всего два файла: <code class="language-plaintext highlighter-rouge">colorizejs.js</code> и <code class="language-plaintext highlighter-rouge">test-colorizejs.js</code>. Мне не очень важно, как именно они названы внутри, так как пространство имен очень маленькое. <del>Я могу даже использовать глобальные переменные.</del> Более короткие имена и меньшие пространства имен означают лучшую поддержку.</p><p><strong>Простые тесты</strong>. Чем больше кодовая база, тем больше зависимостей, которые сложно имитировать и тестировать. Очень большие кодовые базы становятся фундаментально непроверяемыми, так как требуют множества интеграционных тестов, которые сложно поддерживать. Меньшие библиотеки, фреймворки и модули легче поддерживать на уровне простого и быстрого модульного тестирования.</p><p>Таким образом, я считаю, что чем меньше репозитории и модули, тем лучше. Идеально было бы сказать, что максимально допустимый размер кодовой базы составляет 50 000 строк кода. Все, что превышает этот предел, идеально подходит для декомпозиции.</p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">What do you think is better, a bigger code repository with everything inside, or many smaller ones with their own builds, dependencies, issues, and pull requests?</p>&mdash; Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1053922638517731329?ref_src=twsrc%5Etfw">October 21, 2018</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/002 on 2023-08-25 at 06:43</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?218873848f7"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
