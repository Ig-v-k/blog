<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="While many, including Google, advocate for larger monolithic repositories, I strongly believe that the biggest repo should include fewer than 50K lines of code." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Monolithic Repos Are Evil"/> <meta name="twitter:description" property="og:description" content="While many, including Google, advocate for larger monolithic repositories, I strongly believe that the biggest repo should include fewer than 50K lines of code."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2018/09/05/monolithic-repositories.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?adc088812d4"/> <link rel="apple-touch-icon" href="/favicon.ico?adc088812d4"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?adc088812d4"/> <link rel="stylesheet" href="/css/icons.css?adc088812d4"/> <link rel="canonical" href="https://www.yegor256.com/ru/2018/09/05/monolithic-repositories.html" /> <title>Monolithic Repos Are Evil</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Monolithic Repos Are Evil</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2018/09/05/monolithic-repositories.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Мы все храним наш код в репозиториях <del>Git</del> <a href="https://ru.wikipedia.org/wiki/Контроль_версий">контроля версий</a>. Вопрос в том, стоит ли создавать новый репозиторий для каждого нового модуля или пытаться сохранить как можно больше в одном так называемом «монолитном» репозитории (или просто <a href="https://ru.wikipedia.org/wiki/Монорепо">монорепо</a>). Лидеры рынка, такие как <a href="https://code.fb.com/core-data/scaling-mercurial-at-facebook/">Facebook</a> и <a href="https://www.infoq.com/presentations/Development-at-Google">Google</a>, отстаивают второй подход. Я считаю, что они ошибаются.</p><p>Давайте используем следующую функцию JavaScript в качестве примера. Она загружает JSON-документ с узла <a href="http://www.zold.io">Zold</a> (используя <a href="https://jquery.com/">jQuery</a>) и размещает часть его содержимого на HTML-странице. Затем она окрашивает данные в соответствии со своим значением.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
function main() {
  $.getJSON('http://b1.zold.io/', function(json) {
    var $body = $('body');
    $body.text(json.nscore);
    var color = 'red';
    if (json.nscore &gt; 500) {
      color = 'green';
    }
    $body.css('color', color);
  });
}
</code></pre></div></div><p>Довольно очевидно, не так ли? Просто один файл <code class="language-plaintext highlighter-rouge">main.js</code>, который делает все, что нам нужно. Мы просто добавляем его в HTML, и он работает.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"/&gt;
    &lt;script src="main.js"/&gt;
  &lt;/head&gt;
  &lt;body onload="main();"&gt;loading...&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div><p>Теперь позвольте мне переработать это. Разобью его на две части. Первая часть будет загружать данные, а вторая - плагин jQuery для раскраски содержимого HTML в соответствии с данными. Вот так будет выглядеть плагин:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// colorize.js
$.fn.colorize = function() {
  var data = parseFloat(this.text());
  var keys = Object.keys(colors)
    .map(function (k) { return parseInt(k); })
    .sort(function (a,b) { return a - b; })
    .reverse();
  for (i = 0; i &lt; keys.length; ++i) {
    var max = keys[i];
    if (data &gt;= max) {
      this.addClass(colors[max]);
      return;
    }
    this.removeClass(colors[max]);
  }
  return this;
}
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">main.js</code> будет выглядеть следующим образом:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
function main() {
  $.getJSON('http://b1.zold.io/', function(json) {
    $('body')
      .text(json.nscore)
      .colorize({ 500: 'green', 0: 'red' });
  });
}
</code></pre></div></div><p>Теперь, вместо одного монолитного кода, у нас есть две меньшие части, которые должны быть загружены вместе в целевой HTML.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"/&gt;
    &lt;script src="colorize.js"/&gt;
    &lt;script src="main.js"/&gt;
  &lt;/head&gt;
  &lt;body onload="main();"&gt;loading...&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div><p>Два куска лучше, чем один? Кажется, что <a href="https://ai.google/research/pubs/pub45424">Google</a>, <a href="https://blog.digitalocean.com/taming-your-go-dependencies/">Digital Ocean</a> и <a href="https://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">Mozilla</a> так не считают.</p><p>I disagree.</p><p>Для иллюстрации моего утверждения я извлек функцию JavaScript в новый самостоятельный <a href="https://github.com/yegor256/colorizejs">плагин jQuery</a>. Вот что я сделал:</p><ul> <li><p>Создан новый репозиторий GitHub <a href="https://github.com/yegor256/colorizejs">yegor256/colorizejs</a>;</p></li> <li><p>Прочтите <a href="https://learn.jquery.com/plugins/basic-plugin-creation/">инструкции</a>;</p></li> <li><p>Провел(а) некоторое исследование плагинов jQuery, изучил(а) несколько примеров;</p></li> <li><p>Выяснилось, что большинство из них использовали <a href="https://gulpjs.com/">Gulp</a>, о котором я никогда не слышал;</p></li> <li><p>Решили использовать <a href="https://www.npmjs.com/">npm</a> для упаковки JavaScript (что еще, верно?).</p></li> <li><p>Создан <a href="https://github.com/yegor256/colorizejs/blob/master/package.json"><code class="language-plaintext highlighter-rouge">package.json</code></a> для npm;</p></li> <li><p>Переименовал репозиторий на GitHub в <code class="language-plaintext highlighter-rouge">colorizejs</code>, когда узнал, что уже существует пакет npm <a href="https://www.npmjs.com/package/colorize"><code class="language-plaintext highlighter-rouge">colorize</code></a>.</p></li> <li><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.travis.yml"><code class="language-plaintext highlighter-rouge">.travis.yml</code></a> для <a href="https://travis-ci.org/">Travis</a>;</p></li> <li><p>Создал <a href="https://github.com/yegor256/colorizejs/blob/master/README.md">README.md</a> и объяснил, как его использовать и установить.</p></li> <li><p>Решили использовать лицензию MIT и создали <a href="https://github.com/yegor256/colorizejs/blob/master/LICENSE.txt">LICENSE.txt</a>;</p></li> <li><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.pdd">PDD</a> для автоматического сбора головоломок;</p></li> <li><p>Настроен <a href="https://github.com/yegor256/colorizejs/blob/master/.rultor.yml"><code class="language-plaintext highlighter-rouge">.rultor.yml</code></a> для Rultor;</p></li> <li><p>Попытался создать модульный тест и потерпел полный провал (после целого часа исследований), так как у меня почти нет опыта в модульном тестировании на JS.</p></li> <li><p>Опубликовал <a href="https://stackoverflow.com/questions/51809750/">вопрос</a> на Stack Overflow;</p></li> <li><p>Этот вопрос был отвечен только несколькими людьми после того, как я заплатил вознаграждение.</p></li> <li><p>Ответ <a href="https://github.com/brian-lives-outdoors">@brian-lives-outdoors</a> был лучшим, и он даже отправил <a href="https://github.com/yegor256/colorizejs/pull/2">pull request</a> с модульным тестом, который я объединил.</p></li> <li><p>Выпущена первая версия <a href="https://github.com/yegor256/colorizejs/tree/0.0.1">0.0.1</a> на <a href="https://www.npmjs.com/package/colorizejs">npmjs.com</a>;</p></li> <li><p>Изменил код, чтобы он работал с классами и цветами.</p></li> <li><p><a href="https://github.com/yegor256/colorizejs/issues/3">Реализовано</a> и выпущена следующая версия <a href="https://github.com/yegor256/colorizejs/tree/0.1.0">0.1.0</a>;</p></li> <li><p><a href="https://github.com/zold-io/zold.github.io/issues/81">Добавил его</a> во фронтенд Zold, проверил и выпустил его — проверьте <a href="http://www.zold.io/health.html">здесь</a>.</p></li></ul><p>Понадобилось почти три недели ожидания и четыре часа работы, чтобы переместить небольшой фрагмент кода JavaScript в новый репозиторий и выпустить его отдельно. Стоило ли это того? Ну, я думаю, что да. Но большинство других авторов блогов, которых мне удалось найти, считают, что лучше будет держать все в одном монолитном репозитории, главным образом, потому что это лучше для <em>продуктивности</em>. Например, <a href="https://danluu.com/monorepo/">Advantages of monorepos</a> от <a href="https://twitter.com/danluu">Dan Luu</a>, <a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">Advantages and Disadvantages of a Monolithic Repository</a> (case-исследование в Google) от Ciera Jaspan и др., и <a href="https://www.tomasvotruba.cz/blog/2017/01/31/how-monolithic-repository-in-open-source-saved-my-laziness/">How Monolithic Repository in Open Source saved my Laziness</a> от Tomas Votruba.</p><p>Также есть несколько хороших анализов обоих подходов, например выступление <a href="https://www.dotconferences.com/2016/05/fabien-potencier-monolithic-repositories-vs-many-repositories">Monolithic repositories vs. Many repositories</a> Фабьена Потенсье на конференции dotScale 2016 и статья <a href="http://www.gigamonkeys.com/mono-vs-multi/">Repo Style Wars: Mono vs Multi</a> Питера Сейбеля.</p><p>Вкратце говоря, все они утверждают (https://gomonorepo.org/), что производительность выше с монолитным репозиторием, потому что количество операций, которые требуется выполнить для внесения изменений, меньше. Действительно, в монорепо будет одна ветка, один набор коммитов, один запрос на объединение, одно объединение, развертывание и выпуск. Также будет проще тестирование, как вручную, так и с использованием модульного тестирования. Настройка непрерывной интеграции проще, и так далее и тому подобное.</p><p>Все эти “разумные” аргументы напоминают мне то, что я слышу, когда речь идет об разбиении объекта и предложении использовать несколько маленьких объектов вместо одного большого. Представьте себе большой класс из 3 000 строк кода, который делает много разных вещей и все они очень тесно связаны между собой. Его “легко” тестировать, вносить изменения, развертывать, рецензировать и т. д. Ведь все остается в одном файле, верно? Нам не нужно переходить от класса к классу, чтобы понять его структуру. Мы просто смотрим на один экран, прокручиваем его вверх и вниз, и все. Верно? Абсолютно неправильно!</p><p>Думаю, мне не нужно объяснять, почему это неправильно. Мы больше не проектируем наше программное обеспечение таким образом. Мы знаем, что тесная связь - это плохая идея. Мы знаем, что набор меньших компонентов лучше, чем большой сплошной блок.</p><p>Почему мы не можем применить ту же логику к репозиториям? Я считаю, что можем. Конечно, подобно объектно-ориентированному программированию, детальный дизайн требует больше навыков и времени. Посмотрите, что мне пришлось сделать с этим небольшим плагином jQuery. Я потратил часы на кодирование и размышления. Мне даже пришлось изучать <a href="https://gulpjs.com/">Gulp</a> и <a href="https://jasmine.github.io/">Jasmine</a>, которые я, скорее всего, больше не буду использовать. Но выгоды, которые мы получаем от этого, огромны. Вот мой короткий список из них:</p><ul> <li><p><strong>Инкапсуляция</strong>. Каждый репозиторий инкапсулирует одну проблему, скрывая ее детали от всех остальных. Благодаря этому, область, с которой каждый репозиторий должен иметь дело, становится меньше. Чем меньше область, как в ООП, тем легче ее поддерживать и изменять. Чем проще поддерживать, тем дешевле разработка. Полагаю, ребята из Google действительно не беспокоятся о затратах. Напротив, они хотят, чтобы их зарплаты росли. Большой неуправляемый монолитный репозиторий - идеальный инструмент, чтобы это осуществить.</p></li> <li><p><strong>Быстрые сборки</strong>. Когда репозиторий небольшой, время, затрачиваемое на автоматическую сборку, тоже небольшое. Посмотрите на время, которое Travis <a href="https://travis-ci.org/yegor256/colorizejs/builds/420726284">тратит</a> на мою плагин jQuery. Это 51 секунда. Это быстро. Мы <a href="https://mortoray.com/2015/05/06/fast-build-turnaround-time-is-essential/">все знаем</a>, что чем быстрее сборка, тем лучше для продуктивности, так как ее легче использовать в качестве инструмента разработки.</p></li> <li><p><strong>Точные показатели</strong>. Я не знаю, полагаетесь ли вы на метрики в ваших проектах, но мы в <a href="https://www.zerocracy.com">Zerocracy</a> обращаем внимание на числовые показатели, такие как количество строк кода, количество вызовов кода, количество коммитов, классы, методы, связность, связывание и т. д. Всегда возникает вопрос, насколько точны эти показатели. Расчет количества строк кода для большого репозитория не имеет смысла, так как число будет включать множество файлов из совершенно разных частей приложения. Более того, в нем могут быть использованы разные языки и форматы файлов. Предположим, что в репозитории есть 200 000 строк кода на Java, 150 000 строк кода на XML, 50 000 строк кода на JavaScript и 40 000 строк кода на Ruby. Можно ли что-то конкретное сказать об этом репозитории? Он большой? Это репозиторий на Java? И, что еще более важно, можно ли его сравнить с другими репозиториями? Вряд ли. Это просто большое беспорядочное хранилище файлов.</p></li> <li><p><strong>Однородные задачи</strong>. В маленьких репозиториях обычно используется меньше технологических стеков, что означает, что каждый из них использует только несколько языков и фреймворков, или (и это предпочтительная ситуация) - один язык или технологию на один репозиторий. Благодаря этому управление программистами становится проще, поскольку любая заявка/проблема может быть назначена кому угодно. Легче сделать задачи одинакового размера и сложности. Это, очевидно, означает более легкое управление проектом.</p></li> <li><p><strong>Одиночный стандарт кодирования</strong>. Стандартизировать стиль кодирования гораздо проще, если репозиторий небольшой. Когда он большой, различные части кодовой базы будут иметь разные стили, и почти невозможно будет объединить всех на одной странице. Другими словами, более маленькие репозитории выглядят более красиво, чем большие.</p></li> <li><p><strong>Короткие имена</strong>. У каждого репозитория неизбежно будет свое пространство имен. Например, в только что созданном репозитории JS у меня есть всего два файла: <code class="language-plaintext highlighter-rouge">colorizejs.js</code> и <code class="language-plaintext highlighter-rouge">test-colorizejs.js</code>. Мне не очень важно, как они называются внутри, так как пространство имен очень маленькое. <del>Я даже могу использовать глобальные переменные.</del> Более короткие имена и меньшие пространства имен означают более легкую поддержку.</p></li> <li><p><strong>Простые тесты</strong>. Чем больше кодовая база, тем больше зависимостей, которые трудно подделать и протестировать. Очень большие кодовые базы становятся в принципе не тестируемыми, так как требуют множество интеграционных тестов, которые сложно поддерживать. Меньшие библиотеки, фреймворки и модули проще поддерживать на уровне простого и быстрого модульного тестирования.</p></li></ul><p>Таким образом, я считаю, что чем меньше репозитории и модули, тем лучше. В идеале, я бы сказал, что максимально допустимый размер кодовой базы составляет 50 000 строк кода. Все, что превышает эту границу, идеально подходит для декомпозиции.</p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">What do you think is better, a bigger code repository with everything inside, or many smaller ones with their own builds, dependencies, issues, and pull requests?</p>&mdash; Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1053922638517731329?ref_src=twsrc%5Etfw">October 21, 2018</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-08 at 16:59</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?adc088812d4"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
