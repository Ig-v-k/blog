<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Reflection Means Hidden Coupling"/> <meta name="twitter:description" property="og:description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d7375766803"/> <link rel="apple-touch-icon" href="/favicon.ico?d7375766803"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d7375766803"/> <link rel="stylesheet" href="/css/icons.css?d7375766803"/> <link rel="canonical" href="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html" /> <title>Reflection Means Hidden Coupling</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Reflection Means Hidden Coupling</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p><a href="https://en.wikipedia.org/wiki/Reflective_programming">反射式编程</a>（或反射）是指代码能够在运行时自行修改的情况。例如，当我们调用一个类的方法时，它除了其他操作外还会向该类添加一个新的方法（也称为<a href="https://en.wikipedia.org/wiki/Monkey_patch">猴子补丁</a>）。Java、Python、PHP、JavaScript等编程语言都拥有这个“强大”的特性。它有什么问题呢？嗯，它的执行速度<a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">较慢</a>，存在<a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">安全隐患</a>，而且阅读和调试都比较困难。但所有这些与它引入的<em>耦合</em>相比都算不了什么。</p><p>在许多情况下，反射可以“帮助”你。让我们逐一了解这些情况，并看看为什么它们给代码添加的耦合是不必要且有害的。</p><p>Here is the code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}
</code></pre></div></div><p>我不确定每个人都会同意这是反射，但我相信是的：我们在运行时检查类的结构，然后调用在<code class="language-plaintext highlighter-rouge">Iterable</code>中不存在的方法<code class="language-plaintext highlighter-rouge">size()</code>。这个方法只会在运行时“显示出来”，当我们在字节码中创建一个<a href="https://stackoverflow.com/questions/19017258">动态快捷方式</a>时。</p><p>除了以下几点之外，为什么这样做是不好的：1) 它很<a href="http://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">慢</a>，2) 它更冗长，因此<a href="https://armedia.com/blog/instanceof-avoid-in-code/">不容易阅读</a>，并且3) 它引入了一个新的故障点，因为对象<code class="language-plaintext highlighter-rouge">items</code>可能不是<code class="language-plaintext highlighter-rouge">Collection</code>类的实例，从而导致<a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="language-plaintext highlighter-rouge">MethodNotFoundException</code></a>。</p><p>上述代码对整个程序造成的最大问题是它与其客户端之间的耦合，例如：</p><p>这个方法可能起作用，也可能不起作用。这将取决于<code class="language-plaintext highlighter-rouge">list</code>的实际类别。如果它是<code class="language-plaintext highlighter-rouge">Collection</code>，调用<code class="language-plaintext highlighter-rouge">sizeOf</code>将成功。否则，会出现运行时错误。通过查看方法<code class="language-plaintext highlighter-rouge">calc</code>，我们无法确定处理<code class="language-plaintext highlighter-rouge">list</code>以避免运行时错误的正确方式。我们需要阅读<code class="language-plaintext highlighter-rouge">sizeOf</code>的具体内容，然后才能将<code class="language-plaintext highlighter-rouge">calc</code>更改为类似以下的内容：</p><p>这段代码目前看起来是没问题的。然而，当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 的实现发生变化，变成类似这样的情况时会发生什么（我从这篇关于类型转换的文章中摘取了这个示例）？</p><p>现在，<code class="language-plaintext highlighter-rouge">sizeOf</code>可以完美处理任何类型，无论它是<code class="language-plaintext highlighter-rouge">Collection</code>的实例还是其他类型。然而，<code class="language-plaintext highlighter-rouge">calc</code>方法并不知道在<code class="language-plaintext highlighter-rouge">sizeOf</code>方法中所做的更改。相反，它仍然认为如果<code class="language-plaintext highlighter-rouge">sizeOf</code>方法接收到除了<code class="language-plaintext highlighter-rouge">Collection</code>之外的任何参数，它将会出错。为了让它们保持同步，我们必须记住<code class="language-plaintext highlighter-rouge">calc</code>方法对<code class="language-plaintext highlighter-rouge">sizeOf</code>方法了解得太多，并且在<code class="language-plaintext highlighter-rouge">sizeOf</code>方法发生更改时需要修改它。因此，可以说<code class="language-plaintext highlighter-rouge">calc</code>方法与<code class="language-plaintext highlighter-rouge">sizeOf</code>方法耦合在一起，而这种耦合是<em>隐藏的</em>：很可能，当<code class="language-plaintext highlighter-rouge">sizeOf</code>方法得到更好的实现时，我们会忘记修改<code class="language-plaintext highlighter-rouge">calc</code>方法。此外，在程序中可能还有许多类似于<code class="language-plaintext highlighter-rouge">calc</code>方法的其他地方，我们必须记住在<code class="language-plaintext highlighter-rouge">sizeOf</code>方法发生更改时修改它们。显然，我们会忘记其中大部分。</p><p>这种耦合是一个很大的可维护性问题，它是由于Java中反射的存在而引入的。如果我们不能使用<code class="language-plaintext highlighter-rouge">instanceof</code>操作符和类转换（甚至没有它们），这种耦合根本就不可能发生。</p><p>Consider this code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}
</code></pre></div></div><p>如何为这个类及其方法<code class="language-plaintext highlighter-rouge">print()</code>编写单元测试？很显然，如果不重构这个类，几乎是不可能的。<code class="language-plaintext highlighter-rouge">print</code>方法将文本发送到控制台，由于它是“静态”的，我们无法轻易地模拟它。正确的方法是将<code class="language-plaintext highlighter-rouge">System.out</code>作为一个可注入的依赖进行处理，但是我们中的一些人<a href="https://stackoverflow.com/questions/34571">相信</a>反射是更好的选择，这样我们就可以直接测试私有方法<code class="language-plaintext highlighter-rouge">name</code>，而不需要先调用<code class="language-plaintext highlighter-rouge">print</code>方法。</p><p>你还可以使用<a href="https://github.com/powermock/powermock">PowerMock</a> Java库来对私有方法进行许多”美妙”的操作。</p><p>这个测试的问题在于它与被测试的对象紧密耦合：测试太过了解<code class="language-plaintext highlighter-rouge">Book</code>类。测试知道这个类包含一个私有方法<code class="language-plaintext highlighter-rouge">name</code>。测试还知道方法<code class="language-plaintext highlighter-rouge">name</code>将在某个时刻被方法<code class="language-plaintext highlighter-rouge">print</code>调用。测试不是在测试<code class="language-plaintext highlighter-rouge">print</code>，而是在测试它不应该知道的内容：<code class="language-plaintext highlighter-rouge">Book</code>类的内部。</p><p>单元测试的主要目的是对我们程序员来说是一个”安全网”，用来修改之前或者很久以前编写的代码：如果我们出现了任何问题，测试会及时给我们一个信号，”突出显示”代码出错的地方。如果没有突出显示，并且测试都是绿色的，我可以继续修改代码。我依赖于我的测试信息。我相信它们。</p><p>我拿到了<code class="language-plaintext highlighter-rouge">Book</code>类并想要修改它，只是将方法<code class="language-plaintext highlighter-rouge">name</code>的返回类型从<code class="language-plaintext highlighter-rouge">String</code>改为<code class="language-plaintext highlighter-rouge">StringBuilder</code>。这是一个相当无害的修改，可能是出于性能考虑而必要的。在我开始做任何修改之前，我运行了所有的测试（这是一个<a href="https://wiki.c2.com/?TestEveryRefactoring">好的实践</a>）它们全部通过了。然后我做出了我的修改，期望没有测试会失败：</p><p>然而，测试<code class="language-plaintext highlighter-rouge">BookTest</code>将会失败，因为它<em>期望</em>我的类<code class="language-plaintext highlighter-rouge">Book</code>有一个返回<code class="language-plaintext highlighter-rouge">String</code>的<code class="language-plaintext highlighter-rouge">name</code>方法。如果这不是我的测试或者我很久之前写的，我会对这个事实感到沮丧：测试要求我只能用一种特定的方式来编写我的<em>私有</em>方法。为什么？返回<code class="language-plaintext highlighter-rouge">StringBuilder</code>有什么问题吗？我会认为这其中有一些隐藏的原因。否则，为什么一个测试要求私有实现的类做任何事情呢？很快，经过一番调查，我会发现其实没有原因。这只是测试对<code class="language-plaintext highlighter-rouge">Book</code>的内部做出的一种假设，而这个假设除了“我们没有时间重构这个类，使<code class="language-plaintext highlighter-rouge">System.out</code>可以注入”之外没有任何理由。</p><p>顺便说一下，这种测试方法被称为“检查者”测试反模式。</p><p>接下来我会怎么做呢？我需要撤销我的更改，然后开始重构测试和类，以消除这种假设。但是，同时更改测试和主代码是一种<a href="https://stackoverflow.com/questions/1569168">危险的做法</a>：我很可能引入一些新的错误。</p><p>对我来说，这些测试不再是一个“安全网”。我不能信任它们。我修改了代码，我知道我没有犯错。然而，测试却给了我一个红色的信号。在这样一个简单的场景中，我怎么能相信它呢？</p><p>如果不可能使用反射，那么单元测试<code class="language-plaintext highlighter-rouge">BookTest</code>和类<code class="language-plaintext highlighter-rouge">Book</code>之间的这种耦合就不会发生。如果没有人能以任何方式访问私有方法，那么单元测试中的检查者反模式就不会存在。</p><p>当然，如果我们也没有私有方法，生活将会更好。</p><p>这是一个典型工厂的运作方式：</p><p>工厂方法是<code class="language-plaintext highlighter-rouge">make</code>。它期望提供“操作员”的名称，然后使用Java反射API中的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code class="language-plaintext highlighter-rouge">Class.forName()</code></a>构造类的名称，在<a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">类路径</a>中找到它，并创建一个实例。现在，假设有两个类都实现了接口<code class="language-plaintext highlighter-rouge">Operator</code>：</p><p>然后我们使用它们，首先通过调用我们的工厂方法来根据运算符名称创建对象：</p><p><code class="language-plaintext highlighter-rouge">result</code> 将会是 13。</p><p>如果没有反思，我们将无法做到这一点。我们必须改为这样做：</p><p>如果你问我，这段代码看起来更易读和可维护。首先，因为在任何启用<a href="https://www.jetbrains.com/help/idea/navigating-through-the-source-code.html#go_to_declaration">代码导航</a>的IDE中，可以点击“OpMinus”或“OpPlus”，立即跳转到类的主体。其次，类查找的逻辑由JVM提供：我不需要猜测调用“make(“Plus”)”时会发生什么。</p><p>有几个原因使人们喜欢静态工厂。我不同意这些观点。这篇博文解释了原因。如果没有反射，根本无法使用静态工厂，代码会更好、更易于维护。</p><p>在Java中，您可以将注释（DTO-ish接口的实例）附加到类（或其元素，如方法或参数）上。然后可以在运行时或编译时读取注释中的信息。在现代框架（如<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>）中，这个特性经常用于自动化对象的连接：您只需将一些注释附加到您的类上，框架将找到它们，实例化它们，将它们放入DI容器中，并分配给其他对象的属性。</p><p>我之前已经说过，这种发现对象并<em>自动</em>将它们连接在一起的机制是一种反模式。我之前也说过，注释是一种反模式。如果没有反射，依赖注入容器、自动连接以及注释都不会存在。生活会更好，Java/OOP会更清洁。</p><p>注释对象/类的客户端与它们紧密耦合，而这种耦合是<em>隐藏的</em>。注释对象可以更改其接口或修改注释，代码仍然可以编译通过。问题只会在运行时稍后出现，当其他对象的期望未被满足时。</p><p>当程序员不理解面向对象的范式时，他们会制作DTO而不是正确的对象。然后，为了在网络上传输DTO或将其保存到文件中，他们会将其进行序列化或编组。这通常由一个特殊的序列化引擎完成，该引擎接受DTO，突破所有可能的封装障碍，读取其所有字段的值，并将它们打包成JSON格式。</p><p>为了让序列化引擎突破封装障碍，编程语言必须具有反射。首先，因为DTO的某些字段可能是私有的，只能通过反射访问。其次，即使DTO经过正确设计，所有必要的私有字段都有相应的getter方法，仍然需要反射来了解哪些getter方法存在并可以调用。</p><p>序列化对对象的态度与ORM非常相似。它们都不与对象交互，而是以相当”冒犯”的方式将其分解，拿走必要的部分，让可怜的对象失去意识。如果将来一个对象决定改变其结构，重命名某些字段或更改返回值的类型—通过序列化实际上与对象耦合的其他对象将不会注意到任何变化。它们只会在运行时注意到，当”无效的数据格式”异常开始浮现时。对象的开发人员将没有机会注意到，他们对对象接口的更改会影响代码库中的其他地方。</p><p>我们可以说，序列化是一种”完美”地耦合两个对象的方法，以至于两者都不会知道这一点。</p><p>面向对象编程的核心思想是对象为王。只有对象本身可以决定如何处理封装的数据。这一原则的存在和遵守有助于避免由一个简单的场景引起的运行时错误：A使用来自B的数据，而不告诉B如何使用它，然后B更改数据的格式或语义，而A无法理解。</p><p>显然，如果没有反射，这种”滥用”的序列化方式是不可能的。通过对象实现更加谨慎的序列化是可能的，也会被使用，但不是通过反射，而是通过打印机。</p><p>总之，反射引入了隐藏的耦合。这是最危险的耦合类型，因为它难以跟踪，难以发现，也难以移除。没有反射，面向对象设计会更加清洁和稳固。但即使这个特性存在，我建议你在编程语言中永远不要使用反射。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/36 on 2023-11-17 at 12:55</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d7375766803"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
