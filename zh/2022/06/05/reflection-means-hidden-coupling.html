<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Reflection Means Hidden Coupling"/> <meta name="twitter:description" property="og:description" content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?89722679c17"/> <link rel="apple-touch-icon" href="/favicon.ico?89722679c17"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?89722679c17"/> <link rel="stylesheet" href="/css/icons.css?89722679c17"/> <link rel="canonical" href="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html" /> <title>Reflection Means Hidden Coupling</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;386</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Reflection Means Hidden Coupling</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p><a href="https://en.wikipedia.org/wiki/Reflective_programming">反射式编程</a>（或反射）是指代码在运行时自我修改的情况。例如，一个类的方法在调用时，除其他操作外，还向该类添加了一个新方法（也称为<a href="https://en.wikipedia.org/wiki/Monkey_patch">猴子补丁</a>）。Java、Python、PHP、JavaScript等等，它们都具备这种“强大”的功能。这个功能有什么问题呢？嗯，它的问题包括<a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">速度慢</a>、<a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">存在风险</a>、难以阅读和调试。但所有这些与其引入到代码中的<em>耦合性</em>相比，都不算什么。</p><p>有许多情况下，反射可以“帮助”你。让我们遍历所有这些情况，并看看它们为代码添加的耦合为何是不必要且有害的。</p><h2 id="type-checking-and-casting">Type Checking and Casting</h2><p>Here is the code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}
</code></pre></div></div><p>我不确定每个人都会同意这是反射，但我相信它确实是：我们在运行时检查类的结构，然后调用在<code class="language-plaintext highlighter-rouge">Iterable</code>中不存在的<code class="language-plaintext highlighter-rouge">size()</code>方法。这个方法只会在运行时“显示出来”，当我们在字节码中创建一个<a href="https://stackoverflow.com/questions/19017258">动态快捷方式</a>时。</p><p>为什么这种做法不好，除了以下几点：1）它很<a href="http://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">慢</a>，2）它更冗长，因此<a href="https://armedia.com/blog/instanceof-avoid-in-code/">不易读</a>，3）它引入了一个新的故障点，因为对象<code class="language-plaintext highlighter-rouge">items</code>可能不是<code class="language-plaintext highlighter-rouge">Collection</code>类的实例，导致<a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="language-plaintext highlighter-rouge">MethodNotFoundException</code></a>。</p><p>以上的代码对整个程序造成的最大问题是它引入了自身与其客户端之间的耦合，例如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void calc(Iterable&lt;?&gt; list) {
  int s = sizeOf(list);
  System.out.println("The size is " + s);
}
</code></pre></div></div><p>这种方法可能有效，也可能无效。它将取决于<code class="language-plaintext highlighter-rouge">list</code>的实际类别。如果它是<code class="language-plaintext highlighter-rouge">Collection</code>，那么调用<code class="language-plaintext highlighter-rouge">sizeOf</code>将成功。否则，将会出现运行时失败。通过查看<code class="language-plaintext highlighter-rouge">calc</code>方法，我们无法确定如何正确处理<code class="language-plaintext highlighter-rouge">list</code>以避免运行时失败。我们需要阅读<code class="language-plaintext highlighter-rouge">sizeOf</code>的具体内容，然后才能将<code class="language-plaintext highlighter-rouge">calc</code>更改为类似以下的代码：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void calc(Iterable&lt;?&gt; list) {
  if (list instanceof Collection) {
    int s = sizeOf(list);
    System.out.println("The size is " + s);
  } else {
    System.out.println("The size is unknown");
  }
}
</code></pre></div></div><p>这段代码目前看起来是没问题的。然而，当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 改变其实现为类似下面的情况时会发生什么呢（我从这篇关于类型转换的文章中摘取了这个例子）：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  int size = 0;
  if (items instanceof Collection) {
    size = ((Collection) items).size();
  } else {
    for (Object item : items) {
      ++size;
    }
  }
  return size;
}
</code></pre></div></div><p>现在，<code class="language-plaintext highlighter-rouge">sizeOf</code> 完美地处理了任何类型的输入，无论是 <code class="language-plaintext highlighter-rouge">Collection</code> 的实例还是其他类型。然而，<code class="language-plaintext highlighter-rouge">calc</code> 方法不知道在 <code class="language-plaintext highlighter-rouge">sizeOf</code> 方法中所做的更改。相反，它仍然认为除了 <code class="language-plaintext highlighter-rouge">Collection</code> 之外的任何输入都会导致 <code class="language-plaintext highlighter-rouge">sizeOf</code> 出错。为了保持它们同步，我们必须记住 <code class="language-plaintext highlighter-rouge">calc</code> 对 <code class="language-plaintext highlighter-rouge">sizeOf</code> 的了解程度，并在 <code class="language-plaintext highlighter-rouge">sizeOf</code> 发生变化时进行修改。因此，可以说 <code class="language-plaintext highlighter-rouge">calc</code> 与 <code class="language-plaintext highlighter-rouge">sizeOf</code> 相耦合，而这种耦合是<em>隐藏的</em>：很可能，当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 得到更好的实现时，我们会忘记修改 <code class="language-plaintext highlighter-rouge">calc</code>。此外，程序中可能还有许多类似于 <code class="language-plaintext highlighter-rouge">calc</code> 的地方，当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 方法发生变化时，我们必须记住修改它们。显然，我们会忘记其中大部分。</p><p>这种耦合是一个很大的可维护性问题，这是由于 Java 中反射的存在而引入的。如果我们不能使用 <code class="language-plaintext highlighter-rouge">instanceof</code> 运算符和类转换（甚至没有它们），这种耦合本来就不可能存在。</p><h2 id="forceful-testing">Forceful Testing</h2><p>Consider this code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}
</code></pre></div></div><p>如何为这个类以及它的<code class="language-plaintext highlighter-rouge">print()</code>方法编写单元测试呢？显然，如果不重构这个类，几乎是不可能的。<code class="language-plaintext highlighter-rouge">print</code>方法将文本发送到控制台，由于它是“静态”的，我们无法轻松地模拟它。正确的方法是将<code class="language-plaintext highlighter-rouge">System.out</code>作为一个可注入的依赖项，但我们中的一些人<a href="https://stackoverflow.com/questions/34571">认为</a>反射是更好的选择，这将允许我们直接测试私有方法<code class="language-plaintext highlighter-rouge">name</code>，而不必先调用<code class="language-plaintext highlighter-rouge">print</code>。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class BookTest {
  @Test
  void testNamingWorks() {
    Book b = new Book(
      "David West", "Object Thinking"
    );
    Method m = book.getClass().getDeclaredMethod("name");
    m.setAccessible(true);
    assertThat(
      (String) m.invoke(book),
      equalTo("Object Thinking by David West")
    );
  }
}
</code></pre></div></div><p>您还可以使用<a href="https://github.com/powermock/powermock">PowerMock</a> Java库来处理私有方法，实现许多“美妙”的功能。</p><p>这个测试的问题在于它与被测试的对象紧密耦合：测试“知道”太多关于类<code class="language-plaintext highlighter-rouge">Book</code>的信息。测试知道这个类包含一个私有方法<code class="language-plaintext highlighter-rouge">name</code>。测试还知道这个方法<code class="language-plaintext highlighter-rouge">name</code>会被方法<code class="language-plaintext highlighter-rouge">print</code>调用。测试不是在测试<code class="language-plaintext highlighter-rouge">print</code>，而是在测试它不应该知道的东西：类<code class="language-plaintext highlighter-rouge">Book</code>的内部。</p><p>单位测试的主要目的是为我们程序员在尝试修改早期或更早期编写的代码时提供一个“安全网”：如果我们破坏了任何东西，测试会及时向我们发出信号，突出显示代码被破坏的地方。如果没有突出显示任何内容并且测试结果为绿色，我可以继续修改代码。我依赖于我的测试提供的信息。我信任它们。</p><p>我正在修修改变<code class="language-plaintext highlighter-rouge">Book</code>类，只是简单地将<code class="language-plaintext highlighter-rouge">name</code>方法的返回类型从<code class="language-plaintext highlighter-rouge">String</code>修改为<code class="language-plaintext highlighter-rouge">StringBuilder</code>。这是一个相当无害的修改，出于性能考虑可能是必要的。在开始进行任何更改之前，我运行了所有测试（这是一种<a href="https://wiki.c2.com/?TestEveryRefactoring">良好的实践</a>）并且它们全部通过。然后我进行修改，期望没有测试失败。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  // ...
  public void print() {
    System.out.println(
      "The book is: " + this.name().toString()
    );
  }
  private StringBuilder name() {
    return new StringBuilder()
      .append(this.title)
      .append(" by ")
      .append(this.author);
  }
}
</code></pre></div></div><p>然而，测试 <code class="language-plaintext highlighter-rouge">BookTest</code> 将失败，因为它<em>期望</em>我的类 <code class="language-plaintext highlighter-rouge">Book</code> 有一个返回 <code class="language-plaintext highlighter-rouge">String</code> 的 <code class="language-plaintext highlighter-rouge">name</code> 方法。如果这不是我的测试，或者我很久以前写的，我会对这个事实感到沮丧：测试要求我只能以一种特定的方式编写我的<em>私有</em>方法。为什么？返回 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 有什么问题吗？我认为这里肯定有一些隐藏的原因。否则，为什么测试需要对类的私有实现有任何要求？很快，在进行一些调查后我会发现没有原因。这只是测试对 <code class="language-plaintext highlighter-rouge">Book</code> 内部的一种假设，除了“我们没有时间重构这个类并使 <code class="language-plaintext highlighter-rouge">System.out</code> 可注入”之外，这个假设没有任何理由。</p><p>顺便说一下，这种测试方法被称为“检查人员”测试反模式。</p><p>接下来我会做什么？我需要撤销我的更改，然后开始重构测试和类，以摆脱这种假设。然而，同时改变测试和主要代码是一种危险的做法（我相信）：很可能会引入一些新的错误。</p><p>这些测试对我来说已经不再是一个“安全网”了。我无法相信它们。我修改了代码并且知道我没有弄坏任何东西。然而，测试却给我一个红色信号。如果它在这么简单的场景中都说谎，我怎么能相信它呢？</p><p>如果没有办法使用反射，单元测试<code class="language-plaintext highlighter-rouge">BookTest</code>与类<code class="language-plaintext highlighter-rouge">Book</code>之间的耦合就不会发生。如果没有任何方式可以访问私有方法，单元测试中的“检查员”反模式就不可能存在。</p><p>当然，如果我们也没有私有方法，生活会更好。</p><h2 id="factories">Factories</h2><p>这是一个典型工厂的运作方式：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Operator {
  int calc(int a, int b);
}
// This is a Factory Method:
Operator make(String name) {
  try {
    return Class.forName("Op" + name);
  } catch (ClassNotFoundException ex) {
    throw new IllegalStateException(ex);
  }
}
</code></pre></div></div><p>工厂方法是 <code class="language-plaintext highlighter-rouge">make</code>。它期望提供”操作者”的名称，然后使用Java反射API中的<code class="language-plaintext highlighter-rouge">Class.forName()</code>构造类的名称，在类路径中查找并创建一个实例。假设现在有两个类都实现了<code class="language-plaintext highlighter-rouge">Operator</code>接口：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OpPlus implements Operator {
  int calc(int a, int b) {
    return a + b;
  }
}
class OpMinus implements Operator {
  int calc(int a, int b) {
    return a - b;
  }
}
</code></pre></div></div><p>然后我们使用它们，首先要求我们的工厂方法通过运算符名称来创建对象：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int result = make("Plus").calc(
  make("Minus").calc(15, 3),
  make("Minus").calc(8, 7)
);
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">result</code> 的结果将会是13。</p><p>我们无法在没有反思的情况下做到这一点。我们必须这样做：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int result = new OpPlus().calc(
  new OpMinus().calc(15, 3),
  new OpMinus().calc(8, 7)
);
</code></pre></div></div><p>如果你问我，这段代码看起来更易读和易于维护。首先，因为在任何启用代码导航的IDE中，可以点击<code class="language-plaintext highlighter-rouge">OpMinus</code>或<code class="language-plaintext highlighter-rouge">OpPlus</code>并立即跳转到类的主体部分。其次，JVM提供了类查找的逻辑，我不需要猜测当调用<code class="language-plaintext highlighter-rouge">make("Plus")</code>时会发生什么。</p><p>有几个原因使人们喜爱静态工厂。我不同意这些观点。这篇博文解释了为什么。如果没有反射，根本无法使用静态工厂，而且代码会更好且更易维护。</p><h2 id="annotations">Annotations</h2><p>在Java中，您可以将注释（一个DTO-ish接口的实例）附加到类（或其元素，如方法或参数）。然后可以在运行时或编译时读取来自注释的信息。在现代框架（如<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>）中，这个特性经常被用来自动化<a href="https://stackoverflow.com/questions/19414734">对象的连接</a>：您只需将一些注释附加到您的类上，框架将会找到它们，实例化它们，将它们放入DI容器中，并分配给其他对象的属性。</p><p>我之前说过，这种发现对象并<em>自动</em>将它们连接在一起的机制是一种反模式。我之前也说过，注解是一种反模式。如果没有反射，依赖注入容器、自动连接和注解都不会存在。生活会更好，Java/OOP会更加清晰。</p><p>注释对象/类的客户端与它们耦合在一起，这种耦合是<em>隐藏的</em>。一个注释对象可以更改其接口或修改注释，代码仍然可以正常编译。问题只会在运行时才会暴露出来，当其他对象的期望无法满足时。</p><h2 id="serialization">Serialization</h2><p>当程序员不理解面向对象的范式时，他们会制作DTO而不是适当的对象。然后，为了将DTO传输到网络上或将其保存到文件中，他们会对其进行序列化或编组。这通常是由一个特殊的序列化引擎完成的，该引擎接收一个DTO，突破所有可能的封装障碍，读取其所有字段的值，并将它们打包成一个JSON片段。</p><p>为了让序列化引擎突破封装屏障，编程语言必须具备反射能力。首先，因为DTO的某些字段可能是私有的，只能通过反射来访问。其次，即使DTO被设计为具有所有必要的私有字段的getter方法，仍然需要反射来了解哪些getter方法存在并可以被调用。</p><p>对象序列化对待对象的态度与 ORM 很相似。它们都不与对象交流，而是相当“冒犯地”将其拆分，拿走必要的部分，让对象无意识地留下。如果在将来一个对象决定改变其结构，重命名一些字段或更改返回值的类型——实际上通过序列化与该对象相关联的其他对象将察觉不到任何变化。它们会在运行时注意到，当“无效数据格式”异常开始浮出时。对象的开发人员将没有机会注意到他们对对象接口的更改会影响代码库中的其他地方。</p><p>我们可以说序列化是一种“完美”的方法，可以将两个对象耦合在一起，以至于它们中的任何一个都不会知道。</p><p>面向对象编程的核心理念是对象为王。只有对象自己可以决定如何处理其封装的数据。这个原则的存在和遵守有助于避免由一个简单场景引起的运行时错误：A使用来自B的数据，但没有告诉B如何使用这些数据，然后B改变了数据的格式或语义，导致A无法理解。</p><p>很明显，如果没有反射，这样的“滥用”序列化是不可能的。更加谨慎的序列化是可能的，也会被使用，但不是通过反射，而是通过对象实现的打印机。</p><hr /><p>To conclude, reflection introduces coupling, which is hidden. This is the most dangerous type of coupling, because it’s hard to follow, it’s hard to find, and it’s hard to remove. Without reflection object-oriented design would be much cleaner and solid. But even if this feature does exist, I suggest you never use reflection in your programming language.</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Do you use reflective programming (reflection)?</p>&mdash; Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1535919879886446592?ref_src=twsrc%5Etfw">June 12, 2022</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/31 on 2023-08-29 at 18:45</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?89722679c17"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
