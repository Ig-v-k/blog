<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Even though Java annotations are very popular and convenient, they are making Java code less object-oriented and more messy." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Java Annotations Are a Big Mistake"/> <meta name="twitter:description" property="og:description" content="Even though Java annotations are very popular and convenient, they are making Java code less object-oriented and more messy."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2016/04/12/java-annotations-are-evil.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d1b9aa7d6e2"/> <link rel="apple-touch-icon" href="/favicon.ico?d1b9aa7d6e2"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d1b9aa7d6e2"/> <link rel="stylesheet" href="/css/icons.css?d1b9aa7d6e2"/> <link rel="canonical" href="https://www.yegor256.com/zh/2016/04/12/java-annotations-are-evil.html" /> <title>Java Annotations Are a Big Mistake</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Java Annotations Are a Big Mistake</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2016/04/12/java-annotations-are-evil.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p><a href="https://en.wikipedia.org/wiki/Java_annotation">注解</a>是在Java 5中引入的，我们都很激动。这是一个很好的工具，可以使代码更简洁！不再需要Hibernate/Spring的XML配置文件了！就在我们需要它们的代码中，只需要注解就可以了。不再需要<a href="https://en.wikipedia.org/wiki/Marker_interface_pattern">标记接口</a>，只需要一个<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Retention.html">保留运行时</a><a href="http://stackoverflow.com/questions/4296910/">反射可发现</a>的注解！我也很激动。此外，我还创建了一些使用注解的开源库。以<a href="https://github.com/jcabi/jcabi-aspects">jcabi-aspects</a>为例。然而，我不再感到激动了。此外，我认为注解是Java设计中的一个重大错误。</p><p>长话短说，注解存在一个大问题——它们鼓励我们在对象外部实现对象功能，这与封装的基本原则相违背。对象不再是完整的，因为它的行为不完全由自身的方法定义，其中一部分功能留在别处。为什么这是不好的呢？让我们通过几个例子来看看。</p><h2 id="inject"><code class="language-plaintext highlighter-rouge">@Inject</code></h2><p>假设我们用 <code class="language-plaintext highlighter-rouge">@Inject</code> 注释一个属性：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import javax.inject.Inject;
public class Books {
  @Inject
  private final DB db;
  // some methods here, which use this.db
}
</code></pre></div></div><p>然后我们有一个知道要注入什么的注入器：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Injector injector = Guice.createInjector(
  new AbstractModule() {
    @Override
    public void configure() {
      this.bind(DB.class).toInstance(
        new Postgres("jdbc:postgresql:5740/main")
      );
    }
  }
);
</code></pre></div></div><p>现在我们通过容器正在创建一个<code class="language-plaintext highlighter-rouge">Books</code>类的实例。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Books books = injector.getInstance(Books.class);
</code></pre></div></div><p>类<code class="language-plaintext highlighter-rouge">Books</code>不知道如何以及由谁将<code class="language-plaintext highlighter-rouge">DB</code>类的实例注入到其中。这将在幕后并超出其控制范围内发生。注入将完成这一过程。这看起来可能很方便，但这种态度会对整个代码库造成很大的破坏。控制权被失去了（不是被倒置，而是被失去了！）。对象不再负责。它无法对发生的事情负责。</p><p>相反，以下是正确的做法：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Books {
  private final DB db;
  Books(final DB base) {
    this.db = base;
  }
  // some methods here, which use this.db
}
</code></pre></div></div><p>本文解释了为什么依赖注入容器本身就是一个错误的概念：依赖注入容器会让代码变得凌乱。注解基本上会促使我们创建容器并使用它们。我们会将功能从对象中移出，放到容器或其他地方。这是因为我们不想一遍又一遍地重复相同的代码，对吗？的确，重复是不好的，但是将一个对象拆分得支离破碎更加糟糕。更糟糕的是，ORM（JPA/Hibernate）也是如此，注解在其中被广泛使用。阅读这篇文章，它解释了ORM的问题所在：ORM是冒犯性的反模式。注解本身并不是主要的诱因，但它们通过将对象拆分并将各个部分放在不同的地方来帮助我们并鼓励我们。它们是容器、会话、管理器、控制器等等。</p><h2 id="xmlelement"><code class="language-plaintext highlighter-rouge">@XmlElement</code></h2><p>这就是JAXB的工作原理，当你想要将你的POJO转换为XML时。首先，你需要将<code class="language-plaintext highlighter-rouge">@XmlElement</code>注解附加到getter方法上。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
@XmlRootElement
public class Book {
  private final String title;
  public Book(final String title) {
    this.title = title;
  }
  @XmlElement
  public String getTitle() {
    return this.title;
  }
}
</code></pre></div></div><p>然后，您创建一个marshaller并要求它将<code class="language-plaintext highlighter-rouge">Book</code>类的实例转换为XML。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final Book book = new Book("0132350882", "Clean Code");
final JAXBContext ctx = JAXBContext.newInstance(Book.class);
final Marshaller marshaller = ctx.createMarshaller();
marshaller.marshal(book, System.out);
</code></pre></div></div><p>谁在创建XML？不是<code class="language-plaintext highlighter-rouge">book</code>。是另外一个人，在<code class="language-plaintext highlighter-rouge">Book</code>类之外。这是非常错误的。相反，应该这样做。首先，这个类对XML一无所知：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class DefaultBook implements Book {
  private final String title;
  DefaultBook(final String title) {
    this.title = title;
  }
  @Override
  public String getTitle() {
    return this.title;
  }
}
</code></pre></div></div><p>然后，将其打印成XML的装饰器。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class XmlBook implements Book{
  private final Book origin;
  XmlBook(final Book book) {
    this.origin = book;
  }
  @Override
  public String getTitle() {
    return this.origin.getTitle();
  }
  public String toXML() {
    return String.format(
      "&lt;book&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/book&gt;",
      this.getTitle()
    );
  }
}
</code></pre></div></div><p>现在，为了将书打印成XML格式，我们按照以下步骤操作：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String xml = new XmlBook(
  new DefaultBook("Elegant Objects")
).toXML();
</code></pre></div></div><p>XML打印功能位于<code class="language-plaintext highlighter-rouge">XmlBook</code>内部。如果您不喜欢装饰器的想法，可以将<code class="language-plaintext highlighter-rouge">toXML()</code>方法移动到<code class="language-plaintext highlighter-rouge">DefaultBook</code>类中。这不重要。重要的是功能始终保持在对象所属的位置内部。只有对象自己知道如何将自己打印成XML。没有其他人！</p><h2 id="retryonfailure"><code class="language-plaintext highlighter-rouge">@RetryOnFailure</code></h2><p>这是一个例子（来自我的自己的图书馆）：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import com.jcabi.aspects.RetryOnFailure;
class Foo {
  @RetryOnFailure
  public String load(URL url) {
    return url.openConnection().getContent();
  }
}
</code></pre></div></div><p>编译完成后，我们运行一个所谓的AOP织入器，从技术上将我们的代码转化为以下类似的形式：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Foo {
  public String load(URL url) {
    while (true) {
      try {
        return _Foo.load(url);
      } catch (Exception ex) {
        // ignore it
      }
    }
  }
  class _Foo {
    public String load(URL url) {
      return url.openConnection().getContent();
    }
  }
}
</code></pre></div></div><p>我简化了失败时重试方法调用的实际算法，但我相信你可以理解。<a href="http://www.eclipse.org/aspectj/">AspectJ</a>，<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a> 引擎，使用 <a href="http://aspects.jcabi.com/annotation-retryonfailure.html"><code class="language-plaintext highlighter-rouge">@RetryOnFailure</code></a> 注解作为信号，告诉我们该类必须包装到另一个类中。这是在幕后发生的。我们看不到那个补充类，它实现了重试算法。但是 AspectJ 织入器生成的字节码包含了一个修改过的 <code class="language-plaintext highlighter-rouge">Foo</code> 类的版本。</p><p>这就是这种方法的问题所在——我们看不到也无法控制该补充对象的实例化。对象组合是对象设计中最重要的过程，却被隐藏在幕后。你可能会说我们不需要看到它，因为它是补充的。但我不同意。我们必须看到我们的对象是如何组成的。我们可能不关心它们如何工作，但我们必须看到整个组合过程。</p><p>一个更好的设计应该是这样的（而不是注释）：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Foo foo = new FooThatRetries(new Foo());
</code></pre></div></div><p>然后，<code class="language-plaintext highlighter-rouge">FooThatRetries</code> 的实现：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FooThatRetries implements Foo {
  private final Foo origin;
  FooThatRetries(Foo foo) {
    this.origin = foo;
  }
  public String load(URL url) {
    return new Retry().eval(
      new Retry.Algorithm&lt;String&gt;() {
        @Override
        public String eval() {
          return FooThatRetries.this.load(url);
        }
      }
    );
  }
}
</code></pre></div></div><p>现在，<code class="language-plaintext highlighter-rouge">Retry</code> 的实现如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Retry {
  public &lt;T&gt; T eval(Retry.Algorithm&lt;T&gt; algo) {
    while (true) {
      try {
        return algo.eval();
      } catch (Exception ex) {
        // ignore it
      }
    }
  }
  interface Algorithm&lt;T&gt; {
    T eval();
  }
}
</code></pre></div></div><p>代码更长了吗？是的。更干净吗？好多了。我很后悔两年前开始使用<a href="https://github.com/jcabi/jcabi-aspects">jcabi-aspects</a>时没有理解它。</p><hr /><p>The bottom line is that annotations are bad. Don’t use them. What should be used instead? Object composition.</p><p>有什么比注解更糟糕的呢？配置。例如，XML配置。Spring的XML配置机制是糟糕设计的一个完美例子。我以前说过很多次了。让我再重复一遍——Spring框架是Java世界中最糟糕的软件产品之一。如果你能远离它，那将是对自己的一个巨大恩惠。</p><p>在面向对象编程中不应该有任何”配置”。如果对象是真实的对象，我们就不能配置它们，只能实例化它们。而最佳的实例化方法是使用<code class="language-plaintext highlighter-rouge">new</code>操作符。这个操作符是面向对象编程开发者的关键工具。将它从我们手中拿走，给我们提供”配置机制”是一种不可饶恕的罪行。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-09 at 05:14</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d1b9aa7d6e2"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
