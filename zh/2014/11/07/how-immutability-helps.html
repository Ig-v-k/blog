<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="How Immutability Helps"/> <meta name="twitter:description" property="og:description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2014/11/07/how-immutability-helps.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?278749a84ec"/> <link rel="apple-touch-icon" href="/favicon.ico?278749a84ec"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?278749a84ec"/> <link rel="stylesheet" href="/css/icons.css?278749a84ec"/> <link rel="canonical" href="https://www.yegor256.com/zh/2014/11/07/how-immutability-helps.html" /> <title>How Immutability Helps</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">How Immutability Helps</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2014/11/07/how-immutability-helps.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>在最近的一些帖子中，包括”Getters/Setters. Evil. Period. Objects Should Be Immutable”和”Dependency Injection Containers are Code Polluters”，我普遍把所有可变对象标记为”setters”（以<code class="language-plaintext highlighter-rouge">set</code>开头的对象方法）是邪恶的。我的论证主要基于隐喻和抽象示例。显然，这并没有令许多人信服——我收到了一些要求提供更具体和实际的例子。</p><p>因此，为了说明我对“通过设置器改变性质”的强烈负面态度，我拿了一个来自Apache的现有<a href="http://commons.apache.org/proper/commons-email/">commons-email</a> Java库，并按照我的方式重新设计了它，没有设置器，并且以“对象思维”为导向。我将我的库作为<a href="http://www.jcabi.com">jcabi</a>家族的一部分发布——<a href="http://email.jcabi.com">jcabi-email</a>。让我们看看在没有获取器的“纯”面向对象和不可变方法中我们能获得什么好处。</p><p>这是使用commons-email发送电子邮件时代码的样子。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Email email = new SimpleEmail();
email.setHostName("smtp.googlemail.com");
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator("user", "pwd"));
email.setFrom("yegor256@gmail.com", "Yegor Bugayenko");
email.addTo("dude@jcabi.com");
email.setSubject("how are you?");
email.setMsg("Dude, how are you?");
email.send();
</code></pre></div></div><p>以下是如何使用<a href="http://email.jcabi.com">jcabi-email</a>完成相同操作的方法：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Postman postman = new Postman.Default(
  new SMTP("smtp.googlemail.com", 465, "user", "pwd")
);
Envelope envelope = new Envelope.MIME(
  new Array&lt;Stamp&gt;(
    new StSender("Yegor Bugayenko &lt;yegor256@gmail.com&gt;"),
    new StRecipient("dude@jcabi.com"),
    new StSubject("how are you?")
  ),
  new Array&lt;Enclosure&gt;(
    new EnPlain("Dude, how are you?")
  )
);
postman.send(envelope);
</code></pre></div></div><p>我认为差异是显而易见的。</p><p>在第一个示例中，您正在处理一个怪物类，它可以为您做所有事情，包括通过SMTP发送您的MIME消息，创建消息，配置其参数，向其添加MIME部分等等。commons-email的<a href="http://svn.apache.org/viewvc/commons/proper/email/tags/EMAIL_1_3_3/src/main/java/org/apache/commons/mail/Email.java?revision=1609295&amp;view=co"><code class="language-plaintext highlighter-rouge">Email</code></a>类是一个非常庞大的类—有33个私有属性，超过一百个方法，大约两千行代码。首先，您通过一系列的setter方法配置该类，然后要求它为您<code class="language-plaintext highlighter-rouge">send()</code>一封电子邮件。</p><p>在第二个示例中，我们通过七个<code class="language-plaintext highlighter-rouge">new</code>调用实例化了七个对象。<code class="language-plaintext highlighter-rouge">Postman</code>负责将MIME消息打包；<code class="language-plaintext highlighter-rouge">SMTP</code>负责通过SMTP发送消息；邮票（<code class="language-plaintext highlighter-rouge">StSender</code>、<code class="language-plaintext highlighter-rouge">StRecipient</code>和<code class="language-plaintext highlighter-rouge">StSubject</code>）负责在投递之前配置MIME消息；附件<code class="language-plaintext highlighter-rouge">EnPlain</code>负责为我们要发送的消息创建一个MIME部分。我们构建这七个对象，将一个封装到另一个中，然后我们请邮递员代表我们<code class="language-plaintext highlighter-rouge">send()</code>信封。</p><h2 id="whats-wrong-with-a-mutable-email">What’s Wrong With a Mutable Email?</h2><p>从用户的角度来看，几乎没有什么问题。 <code class="language-plaintext highlighter-rouge">Email</code> 是一个功能强大的类，拥有多个控件—只需选择正确的控件，工作就能完成。然而，从开发者的角度来看，<code class="language-plaintext highlighter-rouge">Email</code> 类是一场噩梦。主要是因为这个类非常庞大且难以维护。</p><p><em>由于这个类太大</em>，每次你想通过引入新的方法来扩展它时，你都面临着一个事实，那就是你让这个类变得更糟糕——更长、不连贯、不易读、不易维护等等。你有一种感觉，感觉自己正在深入一些脏东西，而且似乎没有希望使其变得更清洁，永远不可能。我相信，你对这种感觉很熟悉——大多数遗留应用程序看起来都是如此。它们有庞大的多行“类”（实际上是用Java编写的COBOL程序），是由你之前几代程序员继承而来。当你开始时，你充满了活力，但是在滚动这样一个“类”的几分钟后，你会说——“算了吧，差不多周六了”。</p><p>由于班级规模太大，不再有数据隐藏或封装——33个变量可以被100多个方法访问。什么是隐藏的？这个<code class="language-plaintext highlighter-rouge">Email.java</code>文件实际上是一个大型的过程性2000行脚本，错误地称为一个”类”。一旦通过调用其方法跨越类的边界，没有任何东西是隐藏的。此后，您可以完全访问可能需要的所有数据。为什么这样不好？好吧，我们为什么首先需要封装？为了保护一个程序员不受另一个程序员的影响，也就是所谓的防御性编程。当我忙于更改MIME消息的主题时，我希望确保我不会被其他方法的活动干扰，这些方法可能会错误地更改发件人并触碰到我的主题。封装帮助我们缩小问题的范围，而这个<code class="language-plaintext highlighter-rouge">Email</code>类却正好相反。</p><p>由于这个类非常大，它的单元测试比类本身更加复杂。为什么呢？因为其方法和属性之间存在多个相互依赖关系。为了测试<code class="language-plaintext highlighter-rouge">setCharset()</code>方法，你必须调用其他几个方法来准备整个对象，然后必须调用<code class="language-plaintext highlighter-rouge">send()</code>方法来确保发送的消息实际上使用了你指定的编码。因此，为了测试一个只有一行代码的<code class="language-plaintext highlighter-rouge">setCharset()</code>方法，你要运行整个集成测试场景，通过SMTP发送完整的MIME消息。显然，如果某个方法发生了变化，几乎每个测试方法都会受到影响。换句话说，测试非常脆弱、不可靠和过于复杂。</p><p>我可以继续对这个“<em>因为这个类太大</em>”进行讨论，但我认为一个小而有凝聚力的班级总是比一个大班级更好，这对我、对你以及对任何面向对象的程序员来说都是显而易见的。但为什么Apache Commons Email的开发人员却没有意识到这一点呢？我并不认为他们愚蠢或没有受过教育。那么问题出在哪里呢？</p><h2 id="how-and-why-did-it-happen">How and Why Did It Happen?</h2><p>这就是一直发生的情况。你开始将一个类设计为一个连贯、完整和小巧的东西。你的意图非常积极。很快你意识到这个类还有其他事情要做。然后是其他事情。然后是更多的事情。</p><p>让你的类变得越来越强大的最佳方式是通过添加设置器将配置参数注入到类中，以便它可以在内部进行处理，是吗？</p><p>这是问题的根本原因！根本原因是我们通过配置方法将数据<em>插入</em>可变对象中的能力，也被称为“设置器”。当一个对象是可变的并且允许我们随时添加设置器时，我们会毫无限制地这样做。</p><p>让我这样说——<em>可变类往往会变得庞大并失去内聚性</em>。</p><p>如果commons-email的作者们一开始将这个<code class="language-plaintext highlighter-rouge">Email</code>类设为不可变的，他们就无法在其中添加那么多方法并封装那么多属性。他们也不可能将它变成一个庞然大物。为什么呢？因为不可变对象只能通过构造函数来接受状态。你能想象一个有33个参数的构造函数吗？当然不行。</p><p>当你一开始将你的类设计为不可变的时候，你被迫使保持它的内聚性、小巧性、稳固性和健壮性。因为你不能封装太多内容，也不能修改被封装的内容。只需使用两个或三个构造函数的参数，就可以完成任务。</p><h2 id="how-did-i-design-an-immutable-email">How Did I Design An Immutable Email?</h2><p>当我设计<a href="https://github.com/jcabi/jcabi-email">jcabi-email</a>时，我从一个小而简单的类<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>开始。嗯，它是一个接口，因为我从不创建没有接口的类。所以，<code class="language-plaintext highlighter-rouge">Postman</code>是一个邮递员。他将消息传递给其他人。首先，我创建了一个默认版本（为了简洁起见，我省略了构造函数）：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import javax.mail.Message;
@Immutable
class Postman.Default implements Postman {
  private final String host;
  private final int port;
  private final String user;
  private final String password;
  @Override
  void send(Message msg) {
    // create SMTP session
    // create transport
    // transport.connect(this.host, this.port, etc.)
    // transport.send(msg)
    // transport.close();
  }
}
</code></pre></div></div><p>好的开始，它有效。现在怎么办？嗯，<a href="http://docs.oracle.com/javaee/7/api/javax/jms/Message.html"><code class="language-plaintext highlighter-rouge">Message</code></a>很难构建。它是一个复杂的类，来自JDK，需要一些操作才能变成一个漂亮的HTML电子邮件。所以我创建了一个信封，它将为我构建这个复杂的对象（请注意，<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>和<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">Envelope</code></a>都是不可变的，并且使用了<a href="http://aspects.jcabi.com/apidocs-0.20/com/jcabi/aspects/Immutable.html">@Immutable</a>注解来自<a href="http://aspects.jcabi.com/annotation-immutable.html">jcabi-aspects</a>)。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Envelope {
  Message unwrap();
}
</code></pre></div></div><p>我还重构了<code class="language-plaintext highlighter-rouge">Postman</code>，使其能够接受一个信封，而不是一个消息。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Postman {
  void send(Envelope env);
}
</code></pre></div></div><p>到目前为止，一切都很顺利。现在让我们尝试创建一个简单的<code class="language-plaintext highlighter-rouge">Envelope</code>实现。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class MIME implements Envelope {
  @Override
  public Message unwrap() {
    return new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
  }
}
</code></pre></div></div><p>它可以工作，但目前还没有任何有用的功能。它只是创建一个完全空的MIME消息并返回。如果给它添加一个主题以及<code class="language-plaintext highlighter-rouge">To:</code>和<code class="language-plaintext highlighter-rouge">From:</code>地址会怎样呢（请注意，<a href="http://email.jcabi.com/apidocs-1.10/com/jcabi/email/Envelope.Mime.html"><code class="language-plaintext highlighter-rouge">MIME</code></a>类也是不可变的）？</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Envelope.MIME implements Envelope {
  private final String subject;
  private final String from;
  private final Array&lt;String&gt; to;
  public MIME(String subj, String sender, Iterable&lt;String&gt; rcpts) {
    this.subject = subj;
    this.from = sender;
    this.to = new Array&lt;String&gt;(rcpts);
  }
  @Override
  public Message unwrap() {
    Message msg = new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
    msg.setSubject(this.subject);
    msg.setFrom(new InternetAddress(this.from));
    for (String email : this.to) {
      msg.setRecipient(
        Message.RecipientType.TO,
        new InternetAddress(email)
      );
    }
    return msg;
  }
}
</code></pre></div></div><p>看起来正确并且运行良好。但是仍然太简陋了。<code class="language-plaintext highlighter-rouge">CC:</code>和<code class="language-plaintext highlighter-rouge">BCC:</code>怎么办？那电子邮件正文呢？PDF附件怎么办？如果我想指定消息的编码怎么办？<code class="language-plaintext highlighter-rouge">Reply-To</code>呢？</p><p>我可以将所有这些参数添加到构造函数吗？请记住，该类是不可变的，我无法引入<code class="language-plaintext highlighter-rouge">setReplyTo()</code>方法。我必须将<code class="language-plaintext highlighter-rouge">replyTo</code>参数传递到它的构造函数中。但这是不可能的，因为构造函数会有太多的参数，没有人能够使用它。</p><p>So, what do I do?</p><p>我开始思考：我们如何将”信封”的概念分解为更小的概念——这就是我发明的东西。就像现实生活中的信封一样，我的<code class="language-plaintext highlighter-rouge">MIME</code>对象将有邮票。邮票将负责配置<code class="language-plaintext highlighter-rouge">Message</code>对象（同样，<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Stamp.java"><code class="language-plaintext highlighter-rouge">Stamp</code></a>是不可变的，以及其所有的实现者）。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
interface Stamp {
  void attach(Message message);
}
</code></pre></div></div><p>现在，我可以将我的 <a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">MIME</code></a> 类简化为以下内容：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Immutable
class Envelope.MIME implements Envelope {
  private final Array&lt;Stamp&gt; stamps;
  public MIME(Iterable&lt;Stamp&gt; stmps) {
    this.stamps = new Array&lt;Stamp&gt;(stmps);
  }
  @Override
  public Message unwrap() {
    Message msg = new MimeMessage(
      Session.getDefaultInstance(new Properties())
    );
    for (Stamp stamp : this.stamps) {
      stamp.attach(msg);
    }
    return msg;
  }
}
</code></pre></div></div><p>现在，我将为主题、收件人、发件人、抄送人、密送人等创建邮戳。我可以创建任意数量的邮戳。<code class="language-plaintext highlighter-rouge">MIME</code>类将保持不变——小巧、内聚、可读、稳定等。</p><p>重要的是我为什么在这个类相对较小的时候决定进行重构。事实上，在我的 <code class="language-plaintext highlighter-rouge">MIME</code> 类只有25行时，我开始担心这些印记类。</p><p>这正是本文的重点——<em>不可变性迫使你设计小而内聚的对象</em>。</p><p>没有不变性的话，我会走和commons-email一样的路。我的<code class="language-plaintext highlighter-rouge">MIME</code>类会越来越大，迟早会变得和commons-email的<code class="language-plaintext highlighter-rouge">Email</code>一样大。唯一阻止我的是需要重构它的必要性，因为我无法通过构造函数传递所有参数。</p><p>没有不可变性，我就不会有那种动力，我会像Apache开发者在commons-email中所做的那样——膨胀类并将其变成一个难以维护的怪物。</p><p>那是<a href="http://email.jcabi.com">jcabi-email</a>。我希望这个例子足够说明问题，并且你将开始写更干净的、使用不可变对象的代码。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-15 at 15:06</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?278749a84ec"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
