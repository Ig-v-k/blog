<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Java Web App Architecture In Takes Framework"/> <meta name="twitter:description" property="og:description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?790d6e310ac"/> <link rel="apple-touch-icon" href="/favicon.ico?790d6e310ac"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?790d6e310ac"/> <link rel="stylesheet" href="/css/icons.css?790d6e310ac"/> <link rel="canonical" href="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html" /> <title>Java Web App Architecture In Takes Framework</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;387</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Java Web App Architecture In Takes Framework</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2015/03/22/takes-java-web-framework.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>我过去常常使用Servlets、JSP、JAX-RS、Spring Framework、Play Framework、JSF with Facelets和一点Spark Framework。在我个人的观点中，所有这些解决方案都远远不是面向对象和优雅的。它们都充斥着静态方法、无法测试的数据结构和糟糕的技巧。所以大约一个月前，我决定创建自己的Java Web框架。我在其基础上加入了几个基本原则：1）没有NULL值，2）没有公共的静态方法，3）没有可变的类，以及4）没有类转换、反射和<code class="language-plaintext highlighter-rouge">instanceof</code>运算符。这四个基本原则应该保证代码整洁和架构透明。这就是<a href="http://www.takes.org">Takes</a>框架的诞生。让我们看看它创造了什么以及它是如何工作的。</p><h2 id="java-web-architecture-in-a-nutshell">Java Web Architecture in a Nutshell</h2><p>这是我对Web应用架构及其组成部分的简单理解。</p><p>首先，要创建一个网络服务器，我们应该创建一个新的网络套接字，该套接字在特定的TCP端口上接受连接。通常是80，但我将使用8080进行测试。在Java中，可以使用ServerSocket类来实现这一点。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.net.ServerSocket;
public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true);
  }
}
</code></pre></div></div><p>这就足够启动一个网页服务器了。现在，套接字已准备就绪并在8080端口监听。当有人在浏览器中打开<code class="language-plaintext highlighter-rouge">http://localhost:8080</code>时，连接将建立并浏览器将永远显示等待动画。编译这段代码片段并试试看。我们刚刚构建了一个简单的网页服务器，没有使用任何框架。我们目前还没有处理传入的连接，但也没有拒绝它们。所有连接都排队在那个<code class="language-plaintext highlighter-rouge">server</code>对象中。这在后台线程中完成；这就是为什么我们需要在之后加入<code class="language-plaintext highlighter-rouge">while(true)</code>。如果没有这个无限暂停，应用程序将立即结束执行，服务器套接字将关闭。</p><p>下一步是接受传入的连接。在Java中，这是通过对<code class="language-plaintext highlighter-rouge">accept()</code>方法进行阻塞调用来完成的。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final Socket socket = server.accept();
</code></pre></div></div><p>该方法会阻塞其线程并等待新连接的到来。一旦发生这种情况，它会返回一个 <code class="language-plaintext highlighter-rouge">Socket</code> 实例。为了接受下一个连接，我们应该再次调用 <code class="language-plaintext highlighter-rouge">accept()</code>。所以基本上，我们的Web服务器应该像这样工作：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true) {
      final Socket socket = server.accept();
      // 1. Read HTTP request from the socket
      // 2. Prepare an HTTP response
      // 3. Send HTTP response to the socket
      // 4. Close the socket
    }
  }
}
</code></pre></div></div><p>这是一个无休止的循环，接受一个新的连接，理解它，创建一个响应，返回响应，然后再次接受一个新的连接。HTTP协议是无状态的，这意味着服务器不应该记住任何之前连接中发生的事情。它只关心在这个特定连接中收到的HTTP请求。</p><p>HTTP 请求来自套接字的输入流，看起来像一个多行的文本块。如果您读取套接字的输入流，您将看到这样的内容。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final BufferedReader reader = new BufferedReader(
  new InputStreamReader(socket.getInputStream())
);
while (true) {
  final String line = reader.readLine();
  if (line.isEmpty()) {
    break;
  }
  System.out.println(line);
}
</code></pre></div></div><p>您将看到类似于这样的内容：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET / HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: en-US,en;q=0.8,ru;q=0.6,uk;q=0.4
</code></pre></div></div><p>客户端（例如Google Chrome浏览器）将此文本传递到建立的连接中。它连接到<code class="language-plaintext highlighter-rouge">localhost</code>的8080端口，并在连接准备就绪后立即将此文本发送到其中，然后等待响应。</p><p>我们的任务是根据请求中的信息创建一个HTTP响应。如果我们的服务器非常简单，我们可以基本上忽略请求中的所有信息，只需对所有请求返回”Hello, world!”（为了简单起见，我使用了<a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html"><code class="language-plaintext highlighter-rouge">IOUtils</code></a>）。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.net.Socket;
import java.net.ServerSocket;
import org.apache.commons.io.IOUtils;
public class Foo {
  public static void main(final String... args) throws Exception {
    final ServerSocket server = new ServerSocket(8080);
    while (true) {
      try (final Socket socket = server.accept()) {
        IOUtils.copy(
          IOUtils.toInputStream("HTTP/1.1 200 OK\r\n\r\nHello, world!"),
          socket.getOutputStream()
        );
      }
    }
  }
}
</code></pre></div></div><p>就是这样。服务器已准备就绪。尝试编译和运行它。在浏览器中输入 <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>，你将看到 <code class="language-plaintext highlighter-rouge">Hello, world!</code>。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>javac <span class="nt">-cp</span> commons-io.jar Foo.java
<span class="nv">$ </span>java <span class="nt">-cp</span> commons-io.jar:. Foo &amp;
<span class="nv">$ </span>curl http://localhost:8080 <span class="nt">-v</span>

<span class="k">*</span> Rebuilt URL to: http://localhost:8080/

<span class="k">*</span> Connected to localhost <span class="o">(</span>::1<span class="o">)</span> port 8080 <span class="o">(</span><span class="c">#0)</span>

GET / HTTP/1.1 User-Agent: curl/7.37.1 Host: localhost:8080 Accept: <span class="k">*</span>/<span class="k">*</span>

&lt; HTTP/1.1 200 OK

<span class="k">*</span> no chunk, no close, no size. Assume close to signal end &lt;

<span class="k">*</span> Closing connection 0 Hello, world! <span class="sb">```</span>

那就是你创建一个 web 服务器所需要的全部。现在让我们讨论如何使其面向对象和可组合。让我们试着看看 <span class="o">[</span>Takes]<span class="o">(</span>http://www.takes.org<span class="o">)</span> 框架是如何构建的。

<span class="c">## Routing/Dispatching</span>

路由/调度与响应打印在Takes中结合在一起。要创建一个可工作的Web应用程序，您只需要创建一个实现[<span class="sb">`</span>Take<span class="sb">`</span><span class="o">](</span>http://static.javadoc.io/org.takes/takes/1.1/org/takes/Take.html<span class="o">)</span>接口的单个类即可。

</code></pre></div></div><p>import org.takes.Request; import org.takes.Take; public final class TkFoo implements Take { @Override public Response route(final Request request) { return new RsText(“Hello, world!”); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
现在是时候启动服务器了：

</code></pre></div></div><p>import org.takes.http.Exit; import org.takes.http.FtBasic; public class Foo { public static void main(final String… args) throws Exception { new FtBasic(new TkFoo(), 8080).start(Exit.NEVER); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
这个[`FtBasic`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html)类执行了上述相同的套接字操作。它在端口8080上启动了一个服务器套接字，并通过我们在其构造函数中提供的`TkFoo`实例来调度所有传入的连接。它通过一个[`Exit`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/Exit.html)实例，以每秒一次的频率在一个无限循环中进行这个调度，检查是否到达停止的时间。显然，`Exit.NEVER`总是回答“请不要停止”。

## HTTP Request

现在让我们来看看到达`TkFoo`的HTTP请求中有什么，以及我们可以从中获得什么。这是[Takes](http://www.takes.org)中[`Request`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html)接口的定义方式。

</code></pre></div></div><p>public interface Request { Iterable<String> head() throws IOException; InputStream body() throws IOException; }</String></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
请求分为两个部分：头部和正文。头部包含在正文开始的空行之前的所有行，根据HTTP规范[RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)。在框架中，有许多有用的修饰符可以用于`Request`。例如，`RqMethod`可以帮助您从头部的第一行获取方法名。

</code></pre></div></div><p>final String method = new RqMethod(request).method();</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`RqHref` will help extract the query part and parse it. For example, this is the request:

</code></pre></div></div><p>GET /user?id=123 HTTP/1.1 Host: www.example.com</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
这段代码将提取出`123`。

</code></pre></div></div><p>final int id = Integer.parseInt( new RqHref(request).href().param(“id”).get(0) );</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`RqPrint` can get the entire request or its body printed as a `String`:

</code></pre></div></div><p>final String body = new RqPrint(request).printBody();</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
这里的想法是保持`Request`接口简单，并将请求解析功能提供给它的装饰器。这种方法有助于框架保持类的小巧和内聚性。每个装饰器都很小且稳定，只做一件事。所有这些装饰器都在[`org.takes.rq`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/package-summary.html)包中。正如你可能已经理解的那样，`Rq`前缀代表`Request`。

## First Real Web App

让我们创建我们的第一个真正的网络应用程序，它将执行一些有用的操作。我建议从一个 `Entry` 类开始，这是Java要求从命令行启动应用程序的必需类。

</code></pre></div></div><p>import org.takes.http.Exit; import org.takes.http.FtCli; public final class Entry { public static void main(final String… args) throws Exception { new FtCli(new TkApp(), args).start(Exit.NEVER); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
这个类只包含一个`main()`静态方法，当应用程序从命令行启动时，JVM会调用这个方法。如你所见，它实例化了[`FtCli`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtCli.html)，并给它一个`TkApp`类的实例和命令行参数。我们将在接下来创建`TkApp`类。`FtCli`（翻译为“带命令行界面的前端”）创建了一个`FtBasic`的实例，同时为它添加了一些有用的装饰器，并根据命令行参数进行配置。例如，`--port=8080`将被转换为`8080`端口号，并作为`FtBasic`构造函数的第二个参数传递。

这个网络应用本身被称为 `TkApp`，并扩展了 `TsWrap`。

</code></pre></div></div><p>import org.takes.Take; import org.takes.facets.fork.FkRegex; import org.takes.facets.fork.TkFork; import org.takes.tk.TkWrap; import org.takes.tk.TkClasspath; final class TkApp extends TkWrap { TkApp() { super(TkApp.make()); } private static Take make() { return new TkFork( new FkRegex(“/robots.txt”, “”), new FkRegex(“/css/.*”, new TkClasspath()), new FkRegex(“/”, new TkIndex()) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
我们马上会讨论这个 `TkFork` 类。

如果您正在使用Maven，这是您应该开始使用的`pom.xml`文件。

</code></pre></div></div><p>&lt;?xml version=”1.0”?&gt;</p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>foo</groupId> <artifactId>foo</artifactId> <version>1.0-SNAPSHOT</version> <dependencies> <dependency> <groupId>org.takes</groupId> <artifactId>takes</artifactId> <version>0.9</version> </dependency> </dependencies> <build> <finalName>foo</finalName><plugins><plugin> <artifactId>maven-dependency-plugin</artifactId> <executions> <execution> <goals> <goal>copy-dependencies</goal> </goals> <configuration> <outputDirectory>${project.build.directory}/deps</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
运行 `mvn clean package` 应该在 `target` 目录下构建一个 `foo.jar` 文件，并在 `target/deps` 目录中收集所有的 JAR 依赖项。现在你可以从命令行运行该应用程序。

</code></pre></div></div><p>$ mvn clean package $ java -Dfile.encoding=UTF-8 <br /> -cp ./target/foo.jar:./target/deps/* foo.Entry –port=8080</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
应用程序已准备就绪，您可以将其部署到Heroku等平台。只需在存储库的根目录中创建一个`Procfile`文件，并将存储库推送到Heroku即可。`Procfile`应如下所示：

</code></pre></div></div><p>web: java -Dfile.encoding=UTF-8 <br /> -cp target/foo.jar:target/deps/* <br /> foo.Entry –port=${PORT}</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
## `TkFork`

这个[`TkFork`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/TkFork.html)类似乎是框架的核心元素之一。它帮助将一个传入的HTTP请求路由到正确的*take*。它的逻辑非常简单，里面只有几行代码。它封装了一组“forks”，这些“forks”是[`Fork`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/Fork.html)接口的实例。

</code></pre></div></div><p>public interface Fork { Iterator<Response> route(Request req) throws IOException; }</Response></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
它唯一的`route()`方法要么返回一个空迭代器，要么返回一个带有单个`Response`的迭代器。`TkFork`遍历所有的分支，调用它们的`route()`方法，直到其中一个返回响应为止。一旦发生这种情况，`TkFork`将此响应返回给调用者，即[`FtBasic`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html)。

让我们现在自己创建一个简单的分支。例如，当请求“/status”URL时，我们想要显示应用程序的状态。以下是代码：

</code></pre></div></div><p>final class TkApp extends TkWrap { private static Take make() { return new TkFork( new Fork() { @Override public Iterator<Response> route(Request req) { final Collection<Response> responses = new ArrayList&lt;&gt;(1); if (new RqHref(req).href().path().equals("/status")) { responses.add(new TkStatus()); } return responses.iterator(); } } ); } }</Response></Response></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
我相信这里的逻辑是清楚的。我们要么返回一个空的迭代器，要么返回一个包含`TkStatus`实例的迭代器。如果返回了一个空的迭代器，`TkFork`将会尝试在集合中找到另一个实际获得`Response`实例的分叉。顺便说一下，如果什么都没有找到，所有的分叉都返回空的迭代器，`TkFork`将会抛出一个"页面未找到"的异常。

这个精确逻辑是由一个开箱即用的分支实现的，名为`FkRegex`，它试图将请求的URI路径与提供的正则表达式进行匹配。

</code></pre></div></div><p>final class TkApp extends TkWrap { private static Take make() { return new TkFork( new FkRegex(“/status”, new TkStatus()) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
我们可以组合多层结构的 `TkFork` 类；例如：

</code></pre></div></div><p>final class TkApp extends TsWrap { private static Take make() { return new TkFork( new FkRegex( “/status”, new TkFork( new FkParams(“f”, “json”, new TkStatusJSON()), new FkParams(“f”, “xml”, new TkStatusXML()) ) ) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
再次，我相信这是显而易见的。`FkRegex`的实例将请求一个封装的`TkFork`实例返回一个响应，并尝试从一个由`FkParams`封装的实例中获取它。如果HTTP查询是`/status?f=xml`，将返回一个`TkStatusXML`的实例。

## HTTP Response

现在让我们讨论HTTP响应的结构及其面向对象的抽象，[`Response`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Response.html)。以下是接口的外观：

</code></pre></div></div><p>public interface Response { Iterable<String> head() throws IOException; InputStream body() throws IOException; }</String></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
看起来与[`Request`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html)非常相似，不是吗？嗯，它们几乎完全相同，主要是因为HTTP请求和响应的结构几乎相同。唯一的区别在于第一行。

有一系列有用的装饰器可用于构建响应。它们是可组合的，这使得它们非常方便。例如，如果您想构建一个包含HTML页面的响应，可以这样组合它们：

</code></pre></div></div><p>final class TkIndex implements Take { @Override public Response act() { return new RsWithStatus( new RsWithType( new RsWithBody(“&lt;html&gt;Hello, world!&lt;/html&gt;”), “text/html” ), 200 ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
在这个例子中，装饰器`RsWithBody`创建了一个带有主体但没有任何头部的响应。然后，`RsWithType`添加了头部`Content-Type: text/html`。接着，`RsWithStatus`确保响应的第一行包含`HTTP/1.1 200 OK`。

您可以创建自己的装饰器，可以重用现有的装饰器。请看看在 rultor.com 的 [`RsPage`](https://github.com/yegor256/rultor/blob/1.50.2/src/main/java/com/rultor/web/RsPage.java) 中是如何实现的。

## How About Templates?

返回简单的“Hello, world”页面并不是一个大问题，我们可以看到。但是，对于像HTML页面、XML文档、JSON数据集等更复杂的输出，该怎么办呢？有一些方便的`Response`装饰器可以实现这一切。让我们从[Velocity](http://velocity.apache.org)开始，这是一个简单的模板引擎。好吧，它并不是那么简单。它相当强大，但我建议只在简单的情况下使用它。以下是它的工作原理：

</code></pre></div></div><p>final class TkIndex implements Take { @Override public Response act() { return new RsVelocity(“Hello, ${name}”) .with(“name”, “Jeffrey”); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[`RsVelocity`](http://static.javadoc.io/org.takes/takes/1.1/org/takes/rs/RsVelocity.html) 构造函数接受一个参数，该参数必须是一个 Velocity 模板。然后，您调用 `with()` 方法，将数据注入到 Velocity 上下文中。当需要渲染 HTTP 响应时，`RsVelocity` 将根据配置的上下文 "评估" 模板。再次强烈建议您仅在处理简单输出时使用此模板化方法。

对于更复杂的HTML文档，我建议您使用XML/XSLT与Xembly结合使用。我在之前的几篇帖子中解释了这个想法：在浏览器中使用XML+XSLT和RESTful API以及在相同URL中的网站。它简单而强大——Java生成XML输出，XSLT处理器将其转换为HTML文档。这是我们将表示与数据分离的方式。XSL样式表是一个“视图”，`TkIndex`是一个“控制器”，从MVC的角度来看。

我很快会写一篇关于使用Xembly和XSL进行模板化的单独文章。

与此同时，我们将为Takes创建[JSF/Facelets](http://en.wikipedia.org/wiki/Facelets)和[JSP](http://en.wikipedia.org/wiki/JavaServer_Pages)渲染的装饰器。如果您有兴趣帮助，请fork框架并提交您的pull requests。

## What About Persistence?

现在，一个问题是如何处理持久实体，比如数据库、内存结构、网络连接等。我的建议是在`Entry`类内部进行初始化，并将它们作为参数传递到`TkApp`构造函数中。然后，`TkApp`将把它们传递给自定义*takes*的构造函数。

例如，我们有一个包含需要渲染的一些表数据的PostgreSQL数据库。以下是我在`Entry`类中如何初始化与其的连接（我使用了[BoneCP](http://www.jolbox.com/)连接池）：

</code></pre></div></div><p>public final class Entry { public static void main(final String… args) throws Exception { new FtCli(new TkApp(Entry.postgres()), args).start(Exit.NEVER); } private static Source postgres() { final BoneCPDataSource src = new BoneCPDataSource(); src.setDriverClass(“org.postgresql.Driver”); src.setJdbcUrl(“jdbc:postgresql://localhost/db”); src.setUser(“root”); src.setPassword(“super-secret-password”); return src; } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
现在，`TkApp` 的构造函数必须接受一个类型为 `java.sql.Source` 的单一参数。

</code></pre></div></div><p>final class TkApp extends TkWrap { TkApp(final Source source) { super(TkApp.make(source)); } private static Take make(final Source source) { return new TkFork( new FkRegex(“/”, new TkIndex(source)) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`TkIndex` 类还接受一个 `Source` 类的单个参数。我相信你知道在 `TkIndex` 内部如何处理它，以便获取 SQL 表数据并将其转换为 HTML。关键在于该依赖项必须在应用程序（`TkApp` 类的实例）实例化的同时进行注入。这是一种纯净的、无需容器的依赖注入机制。请在《依赖注入容器是代码污染者》中了解更多信息。

## Unit Testing

由于每个类都是不可变的，并且所有依赖关系仅通过构造函数注入，因此单元测试非常容易。假设我们想要测试`TkStatus`，它应该返回一个HTML响应（我正在使用[JUnit 4](http://junit.org/)和[Hamcrest](https://github.com/hamcrest/JavaHamcrest)）：

</code></pre></div></div><p>import org.junit.Test; import org.hamcrest.MatcherAssert; import org.hamcrest.Matchers; public final class TkIndexTest { @Test public void returnsHtmlPage() throws Exception { MatcherAssert.assertThat( new RsPrint( new TkStatus().act(new RqFake()) ).printBody(), Matchers.equalsTo(“&lt;html&gt;Hello, world!&lt;/html&gt;”) ); } }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
此外，我们可以在一个测试HTTP服务器上启动整个应用程序或任何单个"take"，并通过一个真实的TCP套接字测试其行为；例如（我正在使用[jcabi-http](http://http.jcabi.com)进行HTTP请求并检查输出）。

</code></pre></div></div><p>public final class TkIndexTest { @Test public void returnsHtmlPage() throws Exception { new FtRemote(new TkIndex()).exec( new FtRemote.Script() { @Override public void exec(final URI home) throws IOException { new JdkRequest(home) .fetch() .as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_OK) .assertBody(Matchers.containsString(“Hello, world!”)); } } ); } } ```</p><p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtRemote.html"><code class="language-plaintext highlighter-rouge">FtRemote</code></a> 在一个随机的TCP端口上启动一个测试Web服务器，并调用提供的<code class="language-plaintext highlighter-rouge">FtRemote.Script</code>实例的<code class="language-plaintext highlighter-rouge">exec()</code>方法。该方法的第一个参数是刚刚启动的Web服务器主页的URI。</p><p>Takes框架的架构非常模块化和可组合。任何个别的<em>take</em>都可以作为一个独立的组件进行测试，与框架和其他<em>takes</em>完全独立。</p><h2 id="why-the-name">Why the Name?</h2><p>这是我经常听到的问题。这个想法很简单，它起源于电影业。当拍摄电影时，摄制组会拍摄许多“镜头”，以捕捉现实并将其记录在电影胶片上。每次记录都被称为“镜头”。</p><p>换句话说，“take” 就像现实的快照。</p><p>同样适用于这个框架。每个<code class="language-plaintext highlighter-rouge">Take</code>的实例代表了某个特定时刻的现实。然后将这个现实以<code class="language-plaintext highlighter-rouge">Response</code>的形式发送给用户。</p><p>附注：关于身份验证的几个词：使用 Cookie-Based 身份验证在 Takes 框架中的工作方式。</p><p>PPS. 有一些真实的网络系统，你可能会有兴趣去看一下。它们都使用了Takes框架，并且它们的代码是开放的：<a href="https://github.com/yegor256/rultor">rultor.com</a>，jare.io，wring.io。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/35 on 2023-09-06 at 20:18</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?790d6e310ac"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
