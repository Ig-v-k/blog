<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Object-Oriented Declarative Input/Output in Cactoos</title>
    <link rel="canonical" href="https://www.yegor256.com/2017/06/22/object-oriented-input-output-in-cactoos.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/06/22/object-oriented-input-output-in-cactoos.html"
        },
        "headline": "Object-Oriented Declarative Input/Output in Cactoos",
        "image": {
          "@type": "ImageObject",
          "url": "https://www.yegor256.com/images/face-1200x1200.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2017-06-22",
        "dateModified": "2017-06-22",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Instead of calling static procedures we may want
to use objects, the way they are supposed to be used;
that's why Cactoos.
",
        "keywords": ["IO java", "read/write java", "object-oriented input/output", "cactoos", "input/output cactoos"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2017/06/22/object-oriented-input-output-in-cactoos.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>22 June 2017</p>
      <h1>Object-Oriented Declarative Input/Output in Cactoos</h1>
      

<p><a href="http://www.cactoos.org">Cactoos</a> is a library of object-oriented
Java primitives
<a href="https://github.com/yegor256/cactoos#contributors">we</a>
started to work on just a few weeks ago. The intent was to
propose a clean and more declarative alternative to
<a href="https://en.wikipedia.org/wiki/Java_Development_Kit">JDK</a>,
<a href="https://github.com/google/guava">Guava</a>,
<a href="https://commons.apache.org/">Apache Commons</a>,
and others. Instead of calling static
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">procedures</a>
we want to use <a href="/2016/07/14/who-is-object.html">objects</a>,
the way they are supposed to be used. Let’s see how input/output works in a <em>pure</em>
<a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">object-oriented</a>
fashion.</p>



<p><strong>Disclaimer</strong>: The version I’m using at the time of writing is
<a href="https://github.com/yegor256/cactoos/releases/tag/0.9">0.9</a>. Later versions
may have different names of classes and a totally different design.</p>

<p>Let’s say you want to read a file. This is how you would do it with the static method
<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllBytes%28java.nio.file.Path%29"><code class="highlighter-rouge">readAllBytes()</code></a> from the
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">utility class</a>
<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html"><code class="highlighter-rouge">Files</code></a>
in JDK7:</p>

<pre>byte[] content = Files.readAllBytes(
  new File("/tmp/photo.jpg").toPath()
);</pre>

<p>This code is very imperative—it reads the file content right here and now,
placing it into the array.</p>

<p>This is how you do it with <a href="https://github.com/yegor256/cactoos">Cactoos</a>:</p>

<pre>Bytes source = new InputAsBytes(
  new FileAsInput(
    new File("/tmp/photo.jpg")
  )
);</pre>

<p>Pay attention—there are no method calls yet. Just three constructors
of three classes that compose a bigger object. The object <code class="highlighter-rouge">source</code> is of type
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Bytes.html"><code class="highlighter-rouge">Bytes</code></a>
and represents the content of the file. To get that content
out of it we call its method <code class="highlighter-rouge">asBytes()</code>:</p>

<pre>bytes[] content = source.asBytes();</pre>

<p>This is the moment when the file system is touched. This approach, as you
can see, is absolutely declarative and thanks to that possesses all the
benefits of object orientation.</p>

<p>Here is another example. Say you want to write some text into a file. Here
is how you do it in Cactoos. First you need the
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Input.html"><code class="highlighter-rouge">Input</code></a>:</p>

<pre>Input input = new BytesAsInput(
  new TextAsBytes(
    new StringAsText(
      "Hello, world!"
    )
  )
);</pre>

<p>Then you need the <a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Output.html"><code class="highlighter-rouge">Output</code></a>:</p>

<pre>Output output = new FileAsOutput(
  new File("/tmp/hello.txt")
);</pre>

<p>Now, we want to copy the input to the output. There is no “copy” operation
in <em>pure</em> OOP. Moreover, there must be no operations at all. Just objects. We
have a class named
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/io/TeeInput.html"><code class="highlighter-rouge">TeeInput</code></a>,
which is an <code class="highlighter-rouge">Input</code> that copies everything
you read from it to the
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Output.html"><code class="highlighter-rouge">Output</code></a>,
similar to what
<a href="https://commons.apache.org/proper/commons-io/javadocs/api-1.4/org/apache/commons/io/input/TeeInputStream.html"><code class="highlighter-rouge">TeeInputStream</code></a>
from <a href="https://commons.apache.org/">Apache Commons</a> does, but encapsulated. So we don’t copy, we create an
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Input.html"><code class="highlighter-rouge">Input</code></a>
that will copy if you <em>touch</em> it:</p>

<pre>Input tee = new TeeInput(input, output);</pre>

<p>Now, we have to “touch” it. And we have to touch every single byte of it,
in order to make sure they all are copied. If we just <code class="highlighter-rouge">read()</code> the first
byte, only one byte will be copied to the file. The best way to touch them
all is to calculate the size of the <code class="highlighter-rouge">tee</code> object, going byte by byte. We
have an object for it, called
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/io/LengthOfInput.html"><code class="highlighter-rouge">LengthOfInput</code></a>.
It encapsulates an
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/Input.html"><code class="highlighter-rouge">Input</code></a>
and behaves like its length in bytes:</p>

<pre>Scalar&lt;Long&gt; length = new LengthOfInput(tee);</pre>

<p>Then we take the value out of it and the file writing operation takes place:</p>

<pre>long len = length.value();</pre>

<p>Thus, the entire operation of writing the string to the file will
look like this:</p>

<pre>new LengthOfInput(
  new TeeInput(
    new BytesAsInput(
      new TextAsBytes(
        new StringAsText(
          "Hello, world!"
        )
      )
    ),
    new FileAsOutput(
      new File("/tmp/hello.txt")
    )
  )
).value(); // happens here</pre>

<p>This is its procedural alternative from
<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#write%28java.nio.file.Path,%20byte%5B%5D,%20java.nio.file.OpenOption...%29">JDK7</a>:</p>

<pre>Files.write(
  new File("/tmp/hello.txt").toPath(),
  "Hello, world!".getBytes()
);</pre>

<p>“Why is object-oriented better, even though it’s longer?” I hear you ask.
Because it perfectly <strong>decouples</strong> concepts, while the procedural one keeps
them together.</p>

<p>Let’s say, you are designing a class that is supposed
to encrypt some text and save it to a file. Here is how you would
design it the procedural way (not a real encryption, of course):</p>

<pre>class Encoder {
  private final File target;
  Encoder(final File file) {
    this.target = file;
  }
  void encode(String text) {
    Files.write(
      this.target,
      text.replaceAll("[a-z]", "*")
    );
  }
}</pre>

<p>Works fine, but what will happen when you decide to extend it to also write to
an <a href="https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html"><code class="highlighter-rouge">OutputStream</code></a>?
How will you modify this class? How ugly will it look after that?
That’s because the design is not object-oriented.</p>

<p>This is how you would do the same design, in an object-oriented way,
with <a href="http://www.cactoos.org">Cactoos</a>:</p>

<pre>class Encoder {
  private final Output target;
  Encoder(final File file) {
    this(new FileAsOutput(file));
  }
  Encoder(final Output output) {
    this.target = output;
  }
  void encode(String text) {
    new LengthOfInput(
      new TeeInput(
        new BytesAsInput(
          new TextAsBytes(
            new StringAsText(
              text.replaceAll("[a-z]", "*")
            )
          )
        ),
        this.target
      )
    ).value();
  }
}</pre>

<p>What do we do with this design if we want
<a href="https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html"><code class="highlighter-rouge">OutputStream</code></a>
to be accepted? We just add one
<a href="/2015/05/28/one-primary-constructor.html">secondary</a> constructor:</p>

<pre>class Encoder {
  Encoder(final OutputStream stream) {
    this(new OutputStreamAsOutput(stream));
  }
}</pre>

<p>Done. That’s how easy and elegant it is.</p>

<p>That’s because concepts are perfectly separated and functionality
is encapsulated. In the procedural example the behavior of the object is
located outside of it, in the method <code class="highlighter-rouge">encode()</code>. The file itself doesn’t know
how to write, some outside procedure
<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#write%28java.nio.file.Path,%20byte%5B%5D,%20java.nio.file.OpenOption...%29"><code class="highlighter-rouge">Files.write()</code></a>
knows that instead.</p>

<p>To the contrary, in the object-oriented design the
<a href="http://static.javadoc.io/org.cactoos/cactoos/0.9/org/cactoos/io/FileAsOutput.html"><code class="highlighter-rouge">FileAsOutput</code></a>
knows how to write, and nobody else does.
The file writing functionality is encapsulated and this makes it
possible to decorate the objects in any possible way, creating
reusable and replaceable composite objects.</p>

<p>Do you see the beauty of OOP now?</p>

    </article>
  </body>
</html>
