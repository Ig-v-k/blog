<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Fluent Java HTTP Client</title>
    <link rel="canonical" href="https://www.yegor256.com/2014/04/11/jcabi-http-intro.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2014/04/11/jcabi-http-intro.html"
        },
        "headline": "Fluent Java HTTP Client",
        "image": {
          "@type": "ImageObject",
          "url": "https://www.yegor256.com/images/face-1200x1200.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-04-11",
        "dateModified": "2014-04-11",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "I created a simple fluent Java HTTP client to make things
easier with HTTP interactions; the article explains its benefits
comparing with native Java and Apache HttpClient
",
        "keywords": ["alternative to apache http client", "best java http client library", "http client java", "httpclient fluent", "httpclient java", "java http client"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2014/04/11/jcabi-http-intro.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>11 April 2014</p>
      <h1>Fluent Java HTTP Client</h1>
      

<p>In the world of Java, there are plenty of HTTP clients from which to choose.
Nevertheless, I decided to create a new one because none of the other clients
satisfied fully all of my requirements. Maybe, I’m too demanding. Still, this is
how my <a href="http://http.jcabi.com/">jcabi-http</a> client interacts when you make an
HTTP request and expect a successful HTML page in return:</p>

<pre>String html = new JdkRequest("https://www.google.com")
  .uri().path("/users").queryParam("id", 333).back()
  .method(Request.GET)
  .header("Accept", "text/html")
  .fetch()
  .as(RestResponse.class)
  .assertStatus(HttpURLConnection.HTTP_OK)
  .body();</pre>

<p>I designed this new client with the following requirements in mind:</p>



<h2 id="simplicity">Simplicity</h2>

<p>For me, this was the most important requirement. The client must be simple and
easy to use. In most cases, I need only to make an HTTP request and parse the
JSON response to return a value. For example, this is how I use the new client
to return a current EUR rate:</p>

<pre>String uri = "http://www.getexchangerates.com/api/latest.json";
String rate = new JdkRequest(uri)
  .header("Accept", "application/json")
  .fetch()
  .as(JsonResponse.class)
  .json().readArray().getJsonObject(0)
  .getString("EUR");</pre>

<p>I assume that the above is easy to understand and maintain.</p>

<h2 id="fluent-interface">Fluent Interface</h2>



<p>The new client has to be
<a href="/2018/03/13/fluent-interfaces.html">fluent</a>,
which means that the entire server interaction
fits into one Java statement. Why is this important? I think that <a href="http://martinfowler.com/bliki/FluentInterface.html">fluent
interface</a> is the most
compact and expressive way to perform multiple imperative calls. To my
knowledge, none of the existing libraries enable this type of fluency.</p>

<h2 id="testable-and-extensible">Testable and Extensible</h2>

<p>I’m a big fan of interfaces, mostly because they make your designs both cleaner
and highly extensible at the same time. In <a href="http://http.jcabi.com/">jcabi-http</a>,
there are five interfaces extended by 20 classes.</p>

<p><a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/Request.html"><code class="highlighter-rouge">Request</code></a>
is an interface, as well as
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/Response.html"><code class="highlighter-rouge">Response</code></a>,
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/RequestURI.html"><code class="highlighter-rouge">RequestURI</code></a>,
and
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/RequestBody.html"><code class="highlighter-rouge">RequestBody</code></a>
exposed by it.</p>

<p>Use of interfaces makes the library highly extensible. For example, we have
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/request/JdkRequest.html"><code class="highlighter-rouge">JdkRequest</code></a>
and
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/request/ApacheRequest.html"><code class="highlighter-rouge">ApacheRequest</code></a>,
which make actual HTTP calls to the server using two completely
different technologies: (JDK <code class="highlighter-rouge">HttpURLConnection</code> and Apache HTTP Client, respectively).
In the future, it will be possible to introduce new implementations without breaking existing code.</p>

<p>Say, for instance, I want to fetch a page and then do something with it. These two calls perform the task differently, but the end results are the same:</p>

<pre>String uri = "http://www.google.com";
Response page;
page = new JdkRequest(uri).fetch();
page = new ApacheRequest(uri).fetch();</pre>

<h2 id="xml-and-json-out-of-the-box">XML and JSON Out-of-the-Box</h2>

<p>There are two common standards that I wanted the library to support right out of
the box. In most cases, the response retrieved from a server is in either XML or
<a href="/2015/11/16/json-vs-xml.html">JSON</a>
format. It has always been a hassle, and extra work, for me to parse the
output to take care of formatting issues.</p>

<p><a href="http://http.jcabi.com/">jcabi-http</a> client supports them both out of the box,
and it’s possible to add more formats in the future as needed. For example, you
can fetch XML and retrieve a string value from its element:</p>

<pre>String name = new JdkRequest("http://my-api.example.com")
  .header("Accept", "text/xml")
  .fetch()
  .as(XmlResponse.class)
  .xml().xpath("/root/name/text()").get(0);</pre>

<p>Basically, the response produced by <code class="highlighter-rouge">fetch()</code> is decorated by <code class="highlighter-rouge">XmlResponse</code>. This then exposes the <code class="highlighter-rouge">xml()</code> method that returns an instance of the <a href="http://xml.jcabi.com/apidocs-0.7.7/com/jcabi/xml/XML.html"><code class="highlighter-rouge">XML</code></a> interface.</p>

<p>The same can be done with JSON through the Java JSON API
(<a href="https://jcp.org/en/jsr/detail?id=353">JSR-353</a>).</p>

<p>None of the libraries that I’m aware of or worked with offer this feature.</p>

<h2 id="immutable">Immutable</h2>

<p>The last requirement, but certainly not the least important, is that I need all interfaces of the
library to be annotated with <a href="http://aspects.jcabi.com/annotation-immutable.html"><code class="highlighter-rouge">@Immutable</code></a>.
This is important because I need to be able to encapsulate an instance of <code class="highlighter-rouge">Request</code> in other immutable classes.</p>

<p>ps. A short summary of this article was published at
<a href="http://java.dzone.com/articles/jcabi-http-fluent-java-http">JavaLobby</a></p>

    </article>
  </body>
</html>
