<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="How Immutability Helps"/> <meta name="twitter:description" property="og:description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/chinese/2014/11/07/how-immutability-helps.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?987b3885bf7"/> <link rel="apple-touch-icon" href="/favicon.ico?987b3885bf7"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?987b3885bf7"/> <link rel="stylesheet" href="/css/icons.css?987b3885bf7"/> <link rel="canonical" href="https://www.yegor256.com/chinese/2014/11/07/how-immutability-helps.html" /> <title>How Immutability Helps</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;385</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/award.html" title="Software quality award">Award</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">How Immutability Helps</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a translation of the <a href='https://www.yegor256.com/2014/11/07/how-immutability-helps.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>在最近的几篇文章中，包括”Getters/Setters. Evil. Period. Objects Should Be Immutable”和”Dependency Injection Containers are Code Polluters”，我普遍将所有可变对象标记为”setters”（以set开头的对象方法）是邪恶的。我的论证主要基于隐喻和抽象例子。显然，这对你们许多人来说还不够令人信服—我收到了一些要求提供更具体和实际的例子的请求。</p><p>因此，为了表达我对“通过设置器实现可变性”的强烈负面态度，我采用了Apache的现有commons-email Java库，并按照我的方式重新设计了它，没有设置器，并考虑了“对象思维”。我将我的库作为jcabi系列的一部分发布出来——jcabi-email。让我们看看从“纯粹”的面向对象和不可变方法中获得了哪些好处，而没有使用取值器。</p><p>如果您使用commons-email发送电子邮件，您的代码将如下所示：</p><p>java Email email = new SimpleEmail(); email.setHostName(“smtp.googlemail.com”); email.setSmtpPort(465); email.setAuthenticator(new DefaultAuthenticator(“user”, “pwd”)); email.setFrom(“yegor256@gmail.com”, “Yegor Bugayenko”); email.addTo(“dude@jcabi.com”); email.setSubject(“how are you?”); email.setMsg(“Dude, how are you?”); email.send();</p><p>Java Email email = new SimpleEmail(); email.setHostName(“smtp.googlemail.com”); email.setSmtpPort(465); email.setAuthenticator(new DefaultAuthenticator(“user”, “pwd”)); email.setFrom(“yegor256@gmail.com”, “Yegor Bugayenko”); email.addTo(“dude@jcabi.com”); email.setSubject(“你好吗？”); email.setMsg(“朋友，你好吗？”); email.send();</p><p>以下是如何使用jcabi-email执行相同操作的方法：</p><p>java Postman postman = new Postman.Default( new SMTP(“smtp.googlemail.com”, 465, “user”, “pwd”) ); Envelope envelope = new Envelope.MIME( new Array<Stamp>( new StSender("Yegor Bugayenko &lt;yegor256@gmail.com&gt;"), new StRecipient("dude@jcabi.com"), new StSubject("how are you?") ), new Array<Enclosure>( new EnPlain("Dude, how are you?") ) ); postman.send(envelope);</Enclosure></Stamp></p><p>Java邮差 postman = new Postman.Default( new SMTP(“smtp.googlemail.com”, 465, “user”, “pwd”) ); 信封 envelope = new Envelope.MIME( new Array<Stamp>( new StSender("Yegor Bugayenko &lt;yegor256@gmail.com&gt;"), new StRecipient("dude@jcabi.com"), new StSubject("how are you?") ), new Array<Enclosure>( new EnPlain("Dude, how are you?") ) ); postman.send(envelope);</Enclosure></Stamp></p><p>我认为差异很明显。</p><p>在第一个例子中，您正在处理一个怪物类，它可以为您做所有事情，包括通过SMTP发送您的MIME消息，创建消息，配置其参数，向其添加MIME部分等等。commons-email中的Email类确实是一个庞大的类—有33个私有属性，超过一百个方法，大约有两千行代码。首先，您通过一系列的设置器配置该类，然后要求它为您发送()一封电子邮件。</p><p>在第二个例子中，我们通过七个新的调用实例化了七个对象。Postman负责将MIME消息打包；SMTP负责通过SMTP发送消息；邮票（StSender，StRecipient和StSubject）负责在交付之前配置MIME消息；附件EnPlain负责为我们要发送的消息创建一个MIME部分。我们构建这七个对象，将一个封装到另一个中，然后我们请求邮递员代表我们发送()信封。</p><p>从用户角度来看，几乎没有什么问题。电子邮件是一个功能强大的类，有多个控件 — 只需选择正确的控件，工作就可以完成。然而，从开发者的角度来看，电子邮件类是一个噩梦。主要是因为这个类非常庞大且难以维护。</p><p>因为班级如此庞大，每次你想通过引入新的方法来扩展它时，你都面临着这样一个事实：你正在使这个班级变得更糟糕——更长、不连贯、难以阅读、难以维护等等。你有一种感觉，你正在挖掘一些肮脏的东西，而且没有希望让它变得更清洁，永远都没有。我确定你对这种感觉很熟悉——大多数传统应用程序看起来都是这样的。它们有着庞大的多行“类”（实际上是用Java编写的COBOL程序），这些程序是你之前几代程序员遗留下来的。当你开始时，你充满了活力，但是在滚动这样一个“类”几分钟之后，你会说：“算了吧，快到周六了。”</p><p>因为这个班级太大了，所以再也没有数据隐藏或封装了—33个变量可以被100多个方法访问。什么被隐藏了呢？实际上，这个Email.java文件是一个庞大的过程性2000行脚本，错误地被称为一个”类”。一旦通过调用其中一个方法跨越了类的边界，没有任何东西被隐藏了。之后，您就可以完全访问所有可能需要的数据。这为什么不好呢？嗯，我们为什么需要封装呢？为了保护一个程序员免受另一个程序员的影响，也就是所谓的防御性编程。当我忙于更改MIME消息的主题时，我希望确保我不会被其他方法的活动干扰，这些方法可能会错误地更改发件人并触碰我的主题。封装有助于缩小问题的范围，而这个Email类正好相反。</p><p>因为这个类非常大，所以它的单元测试比类本身还要复杂。为什么呢？因为它的方法和属性之间存在多个相互依赖关系。为了测试setCharset()方法，你必须通过调用其他几个方法来准备整个对象，然后你必须调用send()方法来确保发送的消息实际上使用了你指定的编码。因此，为了测试一个一行代码的setCharset()方法，你需要运行整个集成测试场景，通过SMTP发送一个完整的MIME消息。显然，如果某个方法发生了变化，几乎每个测试方法都会受到影响。换句话说，测试非常脆弱、不可靠且过于复杂。</p><p>我可以继续谈论这个“因为班级太大”的问题，但我认为一个小而有凝聚力的班级总是比一个大班级更好。这对我来说、对你来说，以及对任何面向对象的程序员来说都是显而易见的。但为什么对于Apache Commons Email的开发人员来说却不那么明显呢？我不认为他们愚蠢或没有受过教育。那是什么原因呢？</p><p>这就是它总是发生的方式。你开始将一个课程设计为一个有凝聚力、扎实和小规模的东西。你的意图非常积极。很快你就意识到这个班级还有其他事情要做。然后，又有其他事情。接着，甚至更多。</p><p>使你的类变得越来越强大的最佳方法是通过添加设置器(setters)将配置参数注入到类中，以便它可以在内部对它们进行处理，不是吗？</p><p>这是问题的根本原因！根本原因是我们能够通过配置方法，也称为“设置器”，将数据插入可变对象中的能力。当一个对象是可变的并且允许我们随时添加设置器时，我们会毫不犹豫地这样做。</p><p>让我这样解释吧——可变类往往会变得越来越庞大且失去凝聚力。</p><p>如果commons-email的作者在一开始就使这个Email类不可变，他们就不能够在其中添加那么多方法和封装那么多属性。他们也不能够将其转变成一个庞然大物。为什么呢？因为不可变对象只能通过构造函数接受状态。你能想象一个有33个参数的构造函数吗？当然不能。</p><p>当你初始创建一个不可变的类时，你会被迫保持其内聚、小巧、稳固和强大。因为你不能封装太多内容，也不能修改封装的内容。只需使用两个或三个构造函数参数，问题就解决了。</p><p>当我设计jcabi-email时，我从一个小而简单的类开始：Postman。嗯，它是一个接口，因为我从不制作没有接口的类。所以，Postman是一个邮递员。他把消息送给其他人。首先，我创建了一个默认版本（为了简洁起见，我省略了构造函数）：</p><p>请将以下段落从英文翻译成中文，不要更改专有名词：</p><p>java import javax.mail.Message; @Immutable class Postman.Default implements Postman { private final String host; private final int port; private final String user; private final String password; @Override void send(Message msg) { // create SMTP session // create transport // transport.connect(this.host, this.port, etc.) // transport.send(msg) // transport.close(); } }</p><p>好的开始，它有效。现在怎么办？嗯，构建消息很困难。这是一个复杂的JDK类，在它变成一个漂亮的HTML电子邮件之前需要进行一些操作。所以我创建了一个信封，它将为我构建这个复杂的对象（请注意，无论是Postman还是Envelope都是不可变的，并且使用了jcabi-aspects中的@Immutable注解）。</p><p>java @Immutable 接口 信封 { Message unwrap(); }</p><p>我还重构了Postman，使其接受一个信封而不是一个消息：</p><p>java @Immutable 接口 Postman { void send(Envelope env); }</p><p>到目前为止，一切都很好。现在让我们尝试创建一个简单的信封实现：</p><p>java @Immutable 类 MIME 实现 Envelope { @Override public Message unwrap() { return new MimeMessage( Session.getDefaultInstance(new Properties()) ); } }</p><p>它可以运行，但目前还没有任何有用的功能。它只是创建一个完全空的 MIME 消息并返回。要不要给它添加一个主题和收件人地址以及发件人地址（注意，MIME 类也是不可变的）？</p><p>java @Immutable类Envelope.MIME实现Envelope接口{private final String subject; private final String from; private final Array <String> to; public MIME(String subj，String sender，Iterable <String> rcpts){this.subject = subj; this.from = sender; this.to = new Array <String>(rcpts); } @Override public Message unwrap(){Message msg = new MimeMessage（Session.getDefaultInstance（new Properties（）））;msg.setSubject(this.subject); msg.setFrom(new InternetAddress(this.from));for（String email：this.to）{msg.setRecipient（Message.RecipientType.TO，new InternetAddress（email））;}return msg; } }</String></String></String></p><p>看起来正确并且能工作。但它还是太原始了。CC:和BCC:怎么样？电子邮件正文呢？PDF附件呢？如果我想指定消息的编码怎么办？回复地址呢？</p><p>我可以将所有这些参数添加到构造函数中吗？记住，这个类是不可变的，我不能引入setReplyTo()方法。我必须将replyTo参数传递到它的构造函数中。这是不可能的，因为构造函数会有太多的参数，没有人能够使用它。</p><p>So, what do I do?</p><p>嗯，我开始思考：我们如何将“信封”的概念分解为更小的概念——这就是我发明的。就像现实生活中的信封一样，我的MIME对象将有邮票。邮票将负责配置一个消息对象（同样，邮票是不可变的，以及其所有的实现者）：</p><p>java @Immutable 接口 Stamp { void attach(Message message); }</p><p>现在，我可以将我的MIME类简化为以下内容：</p><p>java @Immutable class Envelope.MIME implements Envelope { private final Array<Stamp> stamps; public MIME(Iterable<Stamp> stmps) { this.stamps = new Array<Stamp>(stmps); } @Override public Message unwrap() { Message msg = new MimeMessage( Session.getDefaultInstance(new Properties()) ); for (Stamp stamp : this.stamps) { stamp.attach(msg); } return msg; } }</Stamp></Stamp></Stamp></p><p>Java @Immutable 类 Envelope.MIME 实现 Envelope 接口 { private final Array<Stamp> stamps; public MIME(Iterable<Stamp> stmps) { this.stamps = new Array<Stamp>(stmps); } @Override public Message unwrap() { Message msg = new MimeMessage( Session.getDefaultInstance(new Properties()) ); for (Stamp stamp : this.stamps) { stamp.attach(msg); } return msg; } }</Stamp></Stamp></Stamp></p><p>现在，我将为主题、收件人、发件人、抄送、密送等创建邮票。我可以创建任意数量的邮票。MIME类将保持不变—小巧、紧密、易读、稳定等。</p><p>重要的是为什么我决定在类相对较小的时候进行重构。事实上，当我的MIME类只有25行时，我开始担心这些印章类。</p><p>这正是本文的重点——不可变性迫使你设计小而紧密的对象。</p><p>没有不变性，我会走和commons-email相同的路。我的MIME类会变得越来越庞大，迟早会和commons-email中的Email一样大。唯一阻止我的是重构的必要性，因为我无法通过构造函数传递所有参数。</p><p>没有不变性，我就不会拥有那个激励因素，我会像Apache开发者对待commons-email一样——让类变得臃肿，最终变成一个难以维护的怪物。</p><p>那就是jcabi-email。我希望这个例子足够说明问题，并且你会开始使用不可变对象编写更干净的代码。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/0.0.16 on 22/08/2023 15:08</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?987b3885bf7"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
